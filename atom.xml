<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Davirain</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://davirain-su.github.io/"/>
  <updated>2020-06-28T19:10:42.562Z</updated>
  <id>https://davirain-su.github.io/</id>
  
  <author>
    <name>Davirain</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>程序是怎么跑起来的_第一章对程序员来说CPU是什么</title>
    <link href="https://davirain-su.github.io/2020/06/29/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84_%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%AF%B9%E7%A8%8B%E5%BA%8F%E5%91%98%E6%9D%A5%E8%AF%B4CPU%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>https://davirain-su.github.io/2020/06/29/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84_%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%AF%B9%E7%A8%8B%E5%BA%8F%E5%91%98%E6%9D%A5%E8%AF%B4CPU%E6%98%AF%E4%BB%80%E4%B9%88/</id>
    <published>2020-06-28T19:05:21.861Z</published>
    <updated>2020-06-28T19:10:42.562Z</updated>
    
    <content type="html"><![CDATA[<h1 id="程序是怎么跑起来的"><a href="#程序是怎么跑起来的" class="headerlink" title="程序是怎么跑起来的"></a>程序是怎么跑起来的</h1><h2 id="对程序员来说CPU是什么"><a href="#对程序员来说CPU是什么" class="headerlink" title="对程序员来说CPU是什么"></a>对程序员来说CPU是什么</h2><p>1 程序是什么？</p><p>​    官方答案：指示计算机每一步动作的一组指令</p><p>​    自己的答案：</p><p>2 程序是由什么组成的？</p><p>​    官方答案：指令和数据</p><p>​    自己的答案：</p><p>3 什么是机器语言？</p><p>​    官方答案：CPU可以直接识别并使用的语言， 这是因为CPU能够直接识别和执行的只有机器语言。</p><p>​    自己的答案：操作二进制位的语言</p><p>4 正在运行的程序存储在什么位置？</p><p>​     官方答案：内存</p><p>​    自己答案： 内存， 磁盘和硬盘等媒介上保存的数据被复制到内存后才运行。</p><p>5 什么是内存地址？</p><p>​    官方答案：内存中，用来表示命令和数据存储位置的数值， 内存中保存指令和数据的场所，要通过地址来标记，这个和一个人的来说他的住处，要有他的房间号来表示是一样的。</p><p>​    自己答案：表示内存存在位置的数字</p><p>6 计算机的构成元件中，负责程序的解释和运行的是那个？</p><p>​    官方答案：CPU， 在计算机的构成元件中，根据程序的指令来进行数据运算，并控制整个计算机的设备叫做CPU。</p><p>​    自己的答案： CPU</p><h2 id="CPU：-Central-Processing-Unit-中央处理器"><a href="#CPU：-Central-Processing-Unit-中央处理器" class="headerlink" title="CPU： Central Processing Unit 中央处理器"></a>CPU： Central Processing Unit 中央处理器</h2><p>CPU和内存是由许多晶体管组成的电子部件，称为IC（Integrated Circuit, 集成电路)</p><p> CPU是用来表示计算机内部元件功能的术语</p><p> CPU由具有ON/OFF开关功能的晶体管构成</p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p> 暂存指令，数据等处理对象， 可以将其看作内存的一种，CPU内部有很多寄存器</p><h4 id="寄存器的种类"><a href="#寄存器的种类" class="headerlink" title="寄存器的种类"></a>寄存器的种类</h4><p>累加寄存器 accumulator register : 存储执行运算的数据和运算后的数据，只有一个</p><p>标志寄存器flag register : 存储运算处理后的CPU的状态，只有一个， 不管当前累加器的运算结果是负数，零，正数，标志寄存器都会将其保存。CPU在运算时，标志寄存器的数值会根据运算结果自动设定， 程序中的比较指令，就是在CPU内部做减法运算</p><p>程序计数器 program counter ： 存储下一条指令所在内存的地址， 只有一个， 程序计数器决定着程序的流程</p><p>程序计数器会根据指令占据内存地址的大小，增加与指令长度相应大小的数值</p><h5 id="条件分支和循环机制"><a href="#条件分支和循环机制" class="headerlink" title="条件分支和循环机制"></a>条件分支和循环机制</h5><p>循环执行 ： 按照地址内容的顺序执行指令</p><p>条件分支： 根据条件执行任意地址的指令</p><p>循环执行 ： 重复的执行一个地址的指令</p><p>存在条件分支和循环的话，程序计数器的值会设定为任意地址</p><p>条件分支和循环中使用跳转指令，会根据当前执行的结果来判断是否跳转</p><p>条件分支在跳转指令前会进行比较运算</p><h5 id="函数的调用机制"><a href="#函数的调用机制" class="headerlink" title="函数的调用机制"></a>函数的调用机制</h5><p>通过把程序计数器的值设定成函数的存储地址</p><p>函数调用需要在完成函数内部的处理后，处理流程再返回到函数调用点（函数调用指令的下一个地址）</p><p>这里的问题就是：只是跳转到来函数的入口地址，处理流程就不知道应该返回到哪里</p><p>实现的方式是通过跳转指令来实现函数的调用</p><p>遇到的问题是： 在函数处理结束后应该返回函数执行的下一条指令，可是这里该如何实现将程序计数器的值设定成下一条指令的地址呢？</p><p>问题的解决：通过机器语言的call和return</p><p>call：在函数的入口地址设定到程序计数器之前，call指令会把调用函数后要执行的指令地址存储在栈的主存内</p><p>return：指令的功能是把保存在栈中的地址设定到程序计数器中</p><p>高级语言中也是如此， 函数调用通过call 和 return</p><h5 id="通过地址和索引实现数组"><a href="#通过地址和索引实现数组" class="headerlink" title="通过地址和索引实现数组"></a>通过地址和索引实现数组</h5><p>基址寄存器和变址寄存器，对主内存区域进行区分，来实现类似数组的操作</p><p>cpu会把基址寄存器+变址寄存器解释为实际查看的内存地址</p><p>变址寄存器的值就相当于高级编程语言程序中数组的索引功能</p><p>基址寄存器 base register ： 存储数据内存的起始地址， 有多个</p><p>变址寄存器 index register ： 存储基址寄存器的相对地址，有多个</p><p>通用寄存器 general purpose resgiter： 存储任意数据，有多个</p><p>指令寄存器 instruct resgiter ： 存储指令，只有一个</p><p>栈寄存器 stack register ： 存储栈区域的起始地址， 只有一个</p><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><p>负责把内存上指令、数据等读入寄存器，并根据指令的执行结果来控制整个计算机</p><h3 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h3><p> 负责运算从内存读入寄存器的数据</p><h3 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h3><p>负责发出CPU开始计时的时钟信号，时钟信号 clock puzzle</p><p>寄存器，控制器，运算器，时钟，各个部分之间由电流信号互通</p><p> CPU是寄存器的集合体（程序是把寄存器作为对象来描述的）</p><p>可以从汇编代码中得知机器语言级别的程序是通过寄存器来处理的</p><p>内存的存储场所是通过地址编号来区分的</p><p>寄存器的种类是通过名字来区分的</p><h2 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h2><p>用的助记符来编写程序，原本的电器信号的机器语言指令都有一个与之对应的助记符</p><p>由汇编语言程序编写的程序转化为机器语言的过程： 汇编</p><p>由机器语言转为汇编语言的过程： 反汇编</p><h2 id="机器语言"><a href="#机器语言" class="headerlink" title="机器语言"></a>机器语言</h2><p>CPU能直接解释和执行的语言</p><p>机器语言的指令集有</p><p>数据传送指令： 寄存器和内存，内存和内存，寄存器和外围设备之间的数据读写操作</p><p>运算指令：用累加寄存器执行算术运算、逻辑运算、比较运算和移位运算</p><p>跳转指令： 实现条件分支、循环、强制跳转等</p><p>call/return指令： 函数的调用/返回调用前的地址</p><h2 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h2><p>能够使用类似人类语言的语法来记述的编程语言的总称</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>将高级语言编写的程序转换成机器语言的过程，这个转换的程序称为编译器</p><h2 id="CPU是如何运行的（重点保存指令和数据的寄存器的机制）"><a href="#CPU是如何运行的（重点保存指令和数据的寄存器的机制）" class="headerlink" title="CPU是如何运行的（重点保存指令和数据的寄存器的机制）"></a>CPU是如何运行的（重点保存指令和数据的寄存器的机制）</h2><h2 id="Main-memory主存"><a href="#Main-memory主存" class="headerlink" title="Main memory主存"></a>Main memory主存</h2><p> 主存主要负责存储指令和数据</p><p>通常使用DRAM（Dynamic Random Access Memory 动态随机存取存储器</p><p>主存由可读写的元素构成，每个字节都带有一个地址编号</p><p>CPU可以通过该地址读取主存中地址和数据，或者写入数据</p><p>DRAM可以对任何地址进行数据的读写操作，但需要保持稳定的电源供给并时常刷新，关机后内容将会自动清楚。</p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>指管理和控制计算机硬件与软件资源的计算机程序</p><p>溢出，运算的结果超出来寄存器的长度范围</p><p>奇偶校验， 检查运算结果的值是奇数还是偶数</p><p>了解程序的运行流程是掌握程序运行机制的基础和前提</p><p>CPU所负责的就是解释和运行最终转换成机器语言的程序内容</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;程序是怎么跑起来的&quot;&gt;&lt;a href=&quot;#程序是怎么跑起来的&quot; class=&quot;headerlink&quot; title=&quot;程序是怎么跑起来的&quot;&gt;&lt;/a&gt;程序是怎么跑起来的&lt;/h1&gt;&lt;h2 id=&quot;对程序员来说CPU是什么&quot;&gt;&lt;a href=&quot;#对程序员来说CPU是什么&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>程序是怎么跑起来的</title>
    <link href="https://davirain-su.github.io/2020/06/27/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/"/>
    <id>https://davirain-su.github.io/2020/06/27/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/</id>
    <published>2020-06-26T16:25:12.304Z</published>
    <updated>2020-06-26T16:25:12.305Z</updated>
    
    <content type="html"><![CDATA[<html><head><META http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta content="text/html; charset=utf-8" http-equiv="Content-Type"><meta content="text/css" http-equiv="Content-Style-Type"><title>程序是怎么跑起来的</title><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Davirain" type="application/atom+xml"></head><body><h1 align="center" class="root"><a name="5nhqm41pqc4m3e6el2ord9239d">程序是怎么跑起来的</a></h1><h2 class="topic"><a name="089u4985jvip7i4iur172si0d1">1 对程序员来说CPU是什么</a></h2><h3 class="topic"><a name="2a790rt5i56a27vkc8gu91i2op">&nbsp;CPU Central Processing Unit</a></h3><h3 class="topic"><a name="6dun6910c5t0t9oibg1g9v16hf">&nbsp;&nbsp;寄存器</a></h3><h3 class="topic"><a name="153bdokdim177m30ck64s2t9nk">&nbsp;&nbsp;&nbsp;用来暂存指令 数据等处理对象</a></h3><h3 class="topic"><a name="7ojmo7f8vl3f9uncf00vtvtmam">&nbsp;&nbsp;控制器</a></h3><h3 class="topic"><a name="0ojb775hhsfa6sbctnma0ciquj">&nbsp;&nbsp;&nbsp;负责把内存上的指令、数据等读入寄存器，并根据指令的执行结果来控制整个计算机</a></h3><h3 class="topic"><a name="6jn8s0gs2oi18lbgm5uhrq3st7">&nbsp;&nbsp;运算器</a></h3><h3 class="topic"><a name="4auag06iuab3o9h0j6sn2djknu">&nbsp;&nbsp;&nbsp;负责运算从内存读入寄存器的数据</a></h3><h3 class="topic"><a name="40841ue7vml0uh2geoldh9r7j2">&nbsp;&nbsp;时钟</a></h3><h3 class="topic"><a name="7jkqansk5vc8rft6kg0e2b481q">&nbsp;&nbsp;&nbsp;负责发出CPU开始计时的时钟信号</a></h3><h3 class="topic"><a name="3ghuenjanqsdgsq1kmm7ucnvki">&nbsp;cpu是寄存器的集合体</a></h3><h3 class="topic"><a name="33ajuscodoah7srro4t7g0oep7">&nbsp;&nbsp;程序是把寄存器作为对象来描述</a></h3><h3 class="topic"><a name="7dk1gvckla0652gm8uphla5hi7">&nbsp;&nbsp;编译是指将使用的高级语言编写的程序转换为机器语言的过程，其中用于转换的程序被成为编译器</a></h3><h3 class="topic"><a name="7qpsfmb3pa027h2f59r8g9h2a6">&nbsp;&nbsp;寄存器的种类</a></h3><h3 class="topic"><a name="4hit9ja6l65lr3i5afokq4lkcq">&nbsp;&nbsp;&nbsp;累加寄存器： 存储执行运算的数据和运算后的数据</a></h3><h3 class="topic"><a name="3eindjfrrfehkocl9f1cmhkibe">&nbsp;&nbsp;&nbsp;标志寄存器： 存储元算处理后的CPU状态</a></h3><h3 class="topic"><a name="6di2si6hq0bgtgdajc6b34jdsc">&nbsp;&nbsp;&nbsp;程序计数器：存储下一条指令所在的内存地址</a></h3><h3 class="topic"><a name="48gladg6v4hi0i2jpio4ai1snv">&nbsp;&nbsp;&nbsp;基址寄存器： 存储数据内存的起始地址</a></h3><h3 class="topic"><a name="34phjnjpn09legtouu77nro7s2">&nbsp;&nbsp;&nbsp;变址寄存器： 存储基址寄存器的相对地址</a></h3><h3 class="topic"><a name="56uh5g9bogeplogqv5qm53t5ck">&nbsp;&nbsp;&nbsp;通用寄存器： 存放任意数据</a></h3><h3 class="topic"><a name="7d4btn6hjqt95c10mc2pi1rk47">&nbsp;&nbsp;&nbsp;指令寄存器： 存储指令，CPU内部使用，程序员无法通过程序对该寄存器进行读写</a></h3><h3 class="topic"><a name="1r17u9pjf9vdi9bntu7pie4jij">&nbsp;&nbsp;&nbsp;栈寄存器： 存储栈区域的其实地址</a></h3><h3 class="topic"><a name="2kphtuiugdsu4g5bcvh4v9nf30">&nbsp;&nbsp;程序计数器决定着程序流程的执行</a></h3><h3 class="topic"><a name="2bda8ej6gqmfmtep68esdr2d57">&nbsp;&nbsp;条件分支和循环分支</a></h3><h3 class="topic"><a name="2peohfjm1usv5am8dtfds0b6u7">&nbsp;&nbsp;&nbsp;顺序执行： 是指按照地址内容的顺序执行指令</a></h3><h3 class="topic"><a name="7g7mbdbfj19uch173vtt6ninkk">&nbsp;&nbsp;&nbsp;条件分支：是指根据条件执行任意地址的指令</a></h3><h3 class="topic"><a name="0flcsvsv7qhh9gghvordp45ehr">&nbsp;&nbsp;&nbsp;&nbsp;机器语言的指令可以将程序计数器的值设定为任意地址。这样程序可以返回到上一个地址来重复执行同一个指令</a></h3><h3 class="topic"><a name="6nevut9q7tn2nbgfrg10vb7r3t">&nbsp;&nbsp;&nbsp;循环：是指重复执行同一地址的指令</a></h3><h3 class="topic"><a name="2ugtaithh852k5m14e41olg817">&nbsp;&nbsp;函数调用机制</a></h3><h3 class="topic"><a name="63eu2v0i1amcj7g9nirt9p2bm9">&nbsp;&nbsp;&nbsp;函数调用是通过把程序计数器的值设定成函数的存储地址来实现的，函数调用需要在完成函数内部的处理后，处理流程再返回到函数调用点（函数调用指令的下一个地址）</a></h3><h3 class="topic"><a name="43o5dnjlriv0h5er5gt8e0cc9a">&nbsp;&nbsp;&nbsp;函数调用使用的是call指令，而不是跳转指令。在函数的入口地址设定到程序计数器之前，call指令会把调用函数后要执行的指令地址存储在名为栈的主存内，函数处理完毕后，再通过函数的出口来执行return指令</a></h3><h3 class="topic"><a name="09v2n3s4tb4lir25dlpiba0ibc">&nbsp;&nbsp;&nbsp;return命令的功能是把保存在栈中的地址设定到程序计数器中。</a></h3><h3 class="topic"><a name="4bvsate68n6cpqcdvdvo0emnmv">&nbsp;&nbsp;通过地址和索引实现数组</a></h3><h3 class="topic"><a name="0j9i6rc0rabecf6oo4ecrfi111">&nbsp;&nbsp;&nbsp;基址寄存器和变址寄存器，通过这两个寄存器可以对主存上特定的内存区域进行划分，从而实现类似数组的操作。</a></h3><h3 class="topic"><a name="6rfl42nd6d7p9663vp4g741abn">&nbsp;&nbsp;&nbsp;cpu会把基址寄存器 + 变址寄存器的值解释为实际查看的内存地址。变址寄存器的值相当于高级编程语言程序中数组的索引功能。</a></h3><h3 class="topic"><a name="6uto8dnl12p00ocqvcbs1vv6d6">&nbsp;&nbsp;机器指令的主要类型和功能</a></h3><h3 class="topic"><a name="5b0m3ks6dtqtcq19t9h0c21q16">&nbsp;&nbsp;&nbsp;数据发送指令： 寄存器和内存，内存和内存、寄存器和外围设备之间的数据读写操作</a></h3><h3 class="topic"><a name="3rc6ijdi0v4u6e9j5bavrb3b1n">&nbsp;&nbsp;&nbsp;运算指令：用累加寄存器执行算术操作、逻辑运算、比较运算和移位运算</a></h3><h3 class="topic"><a name="466d19euru1n5e3a98slbm0abl">&nbsp;&nbsp;&nbsp;跳转指令：实现条件分支、循环强制跳转等</a></h3><h3 class="topic"><a name="4hb4u009060ntjp08qsujotj8r">&nbsp;&nbsp;&nbsp;call/return： 函数的调用 返回调用前的地址</a></h3><h2 class="topic"><a name="6p7sg8pcdi0qof3f7gabavs9g6">2 数据使用二进制数表示的</a></h2><h3 class="topic"><a name="1ftcl47ll4t6icf31bpp5frpv9">&nbsp;用二进制表示计算机信息的原因</a></h3><h3 class="topic"><a name="51vojlof16ftt1j8gnmfh5ie65">&nbsp;&nbsp;IC的所有引脚，只有直流电0V或5V两个状态。</a></h3><h3 class="topic"><a name="1pl5eq12c2qfs3gagkbbgi98cq">&nbsp;&nbsp;计算机处理信息的最小单位 -- 位，相当于二进制中的一位</a></h3><h3 class="topic"><a name="2a40jbo5k24ojfvgjdsda7bg51">&nbsp;&nbsp;8位二进制数称为一个字节，字节是最基本的信息计量单位，位是最小单位。字节是基本单位。内存和磁盘都是使用字节单位来存储和读写数据，使用位单位则无法读写数据。因此字节是信息的基本单位。</a></h3><h3 class="topic"><a name="656bebvbcsedgkic58klru78ak">&nbsp;&nbsp;如果数字小于存储数据的字节数，那么高位就用0来填补。</a></h3><h3 class="topic"><a name="6a7mmth50k0i3a4t59upbcaedd">&nbsp;&nbsp;0包含在正数范围内，所以负数就要比正数多1，虽然0不是正数，但考虑到符号位，就将其划分到正数中。</a></h3><h3 class="topic"><a name="42aqulbihtr4040gdhe2r12hcu">&nbsp;逻辑右移和算数右移</a></h3><h3 class="topic"><a name="1bnm1if43lrm439sa20cq0r2ha">&nbsp;&nbsp;只有在右移时才必须区分逻辑位移和算术位移。左移时，无论是位图模式（逻辑左移）还是相乘运算（算术左移），都只需在空出来低位补0即可。</a></h3><h3 class="topic"><a name="3ktk9beakelpmdp0un7unib53e">&nbsp;掌握逻辑运算的窍门</a></h3><h3 class="topic"><a name="0as1gclplinhu9mikgenhpvhpd">&nbsp;&nbsp;将二进制数表示的信息作为四则运算的数值来处理就是算术</a></h3><h3 class="topic"><a name="3ia7cosn88kkdcofbqblavmjsi">&nbsp;&nbsp;算术运算： 指加减乘除四则运算</a></h3><h3 class="topic"><a name="0p4b6kru4cbs3v6b3thlr30dka">&nbsp;&nbsp;逻辑运算：是指对二进制各数字位的0和1分别进行处理的运算，包括逻辑非NOT、逻辑与AND、逻辑或OR和逻辑异或XOR</a></h3><h2 class="topic"><a name="594fnondnt9c6jafgha81iq6l1">3 计算机进行小数运算时出错的原因</a></h2><h3 class="topic"><a name="4tssvseau3k60gisc8a6l35n97">&nbsp;计算机运算出错的原因</a></h3><h3 class="topic"><a name="0ncf7u5ipagfv30631prpfmg4g">&nbsp;&nbsp;有一些十进制数无法转换成二进制数</a></h3><h3 class="topic"><a name="7gffadsq3g6hae4vnh1ddsmmf4">&nbsp;什么是浮点数</a></h3><h3 class="topic"><a name="0gqc3lnu2rvfs4ib8c872chrqu">&nbsp;&nbsp;双精度浮点数类型用64位，单精度浮点数用32位来表示全体小数</a></h3><h3 class="topic"><a name="00c0oc573n6im3501vb86l3jhk">&nbsp;&nbsp;浮点数是指用符号、尾数、基数和指数这四部分来表示的小数</a></h3><h3 class="topic"><a name="5tm6iubn91et70322a73u1nhid">&nbsp;&nbsp;尾数部分用的是：将小数点前面的值固定位1的正则表达式，而指数部分用的则是EXCESS系统表示</a></h3><h3 class="topic"><a name="6et1q5ee00e9fecokcu9i5o4ep">&nbsp;正则表达式和Excess系统</a></h3><h3 class="topic"><a name="4ono96fn4lnke4r1mi7u1js5si">&nbsp;&nbsp;尾数部分使用正则表达式</a></h3><h3 class="topic"><a name="7h5lb4hc82fcc9naptgmm6gvgi">&nbsp;&nbsp;将小数点前面的值固定位1的正则表达式</a></h3><h3 class="topic"><a name="7ii0e7971ee4fhcl1s48im4l3r">&nbsp;&nbsp;按照规定的规则来表示的形式即为正则表达式。除了小数之外，字符串以及数据库等，也都有各自的正则表达式。</a></h3><h3 class="topic"><a name="0h92oqc0f5n872860lhl9082nr">&nbsp;&nbsp;EXCESS系统表现是指，通过将指数部分表示范围的中间值设为0，使得负数不需要用符号来表示。即，当指数部分为8位单精度浮点数时，最大值11111111 = 255 的1/2， 即011111111 = 127 小数部分舍弃表示的是0</a></h3><h3 class="topic"><a name="3e7og3v2d47hgredbaag95kosf">&nbsp;如何避免计算机计算出错</a></h3><h3 class="topic"><a name="3crstvq91784nge4m3e9k92uub">&nbsp;&nbsp;计算机出错的原因之一，采用浮点数来处理小数，作为程序的数据类型，不管使用的是单精度还是双精度 都存在计算出错的可能性。</a></h3><h3 class="topic"><a name="43a6adekf60tto58lvr1eu7opo">&nbsp;&nbsp;两种解决策略： 1 回避策略 2 把小数转换成正数计算</a></h3><h3 class="topic"><a name="2k18jph70v060g1sb44gipdrgp">&nbsp;&nbsp;BCD 也是一种使用二进制表示十进制的方法</a></h3><h2 class="topic"><a name="7t1tlimq0t4tq3mbph2u07r9a0">4 熟练使用有棱角的内存</a></h2><h2 class="topic"><a name="5eff7r5rm7jivns3cp4hhprvar">硬件控制方法</a></h2><h2 class="topic"><a name="3s243uv1e2mk19mi3nvrbt5jrh">让计算机思考</a></h2><h2 class="topic"><a name="3k07ag08sp1hq238oi40fqee22">让我们开始C语言之旅</a></h2><h2 class="topic"><a name="7j4muaq8u2hvfstffd84gb2vrm">内存和磁盘的亲密关系</a></h2><h2 class="topic"><a name="1kacprki3omr1450un9fuihiek">亲自尝试压缩数据</a></h2><h2 class="topic"><a name="1ahgbck0dhj8evc6nalo0p5mhg">程序是在何种环境中运行的</a></h2><h2 class="topic"><a name="4g60renrlionjmn5sh5719spcj">从源文件到可执行文件</a></h2><h2 class="topic"><a name="1tf1h258gga7sadksice1b7mki">操作系统和应用的关系</a></h2><h2 class="topic"><a name="5spth4lagbqrhdkcsuqbcalths">通过汇编语言了解程序的实际构成</a></h2></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;
&lt;head&gt;
&lt;META http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
&lt;meta content=&quot;text/html; charset=utf-8&quot; http-equiv=&quot;Conte
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>第二章 语言精要</title>
    <link href="https://davirain-su.github.io/2020/06/26/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%A6%81/"/>
    <id>https://davirain-su.github.io/2020/06/26/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%A6%81/</id>
    <published>2020-06-26T04:11:19.830Z</published>
    <updated>2020-06-27T16:18:32.186Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rust-编程之道-第二章-语言精要"><a href="#Rust-编程之道-第二章-语言精要" class="headerlink" title="Rust 编程之道 第二章 语言精要"></a>Rust 编程之道 第二章 语言精要</h1><p>​                                                                                                                                        好读书，不求甚解；每有会意，便欣然忘食。</p><p><strong>动手，动手，动手！！！</strong></p><h2 id="语句与表达式"><a href="#语句与表达式" class="headerlink" title="语句与表达式"></a>语句与表达式</h2><p>Rust 中语法可以分成两大类：<strong>语句 statement 和表达式 expression。</strong>语句是指要执行的一些操作和产生副作用的表达式。</p><p>表达式主要用于计算求值。</p><p>语句又分为两种：<strong>声明语句 Declaration statment 和表达式语句 Expression statement</strong></p><ul><li>声明语句，用于声明各种语言项，包括声明变量、静态变量、常量、结构体、函数等，以及通过extern 和use关键字引入包和模块。</li><li>表达式语句，特指以分号结尾的表达式。此类表达式求值结果将会被舍弃，并总是返回单元类型（）。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//extern crate std; </span></span><br><span class="line"><span class="comment">// use std::prelude::v1::*;</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">answer</span></span>() -&gt; () &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">40</span>;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(sum(a,b), <span class="number">42</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sum</span></span>(a: <span class="built_in">i32</span>, b: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span>&#123;</span><br><span class="line">    a + b</span><br><span class="line">  &#125;</span><br><span class="line">  answer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        Extern cate std; 和 use std::prelude::v1::*; 是声明语句，他们并不需要求值，只是用来引入标准库包以及prelude模块。</p><p>​        rust 会为每个crate都自动引入标准库模块，除非使用#[no_std]属性明确指定了不需要标准库。</p><p>​        使用fn关键子定义了函数，函数answer没有输入参数，并且返回类型为<strong>单元类型（）</strong>。单元类型拥有唯一的值，就是它本身，为了描述方便，将该值称为<strong>单元值</strong>。单元类型的概念来自Ocmal，他表示“没有什么特殊的值”。所以，这里将单元类型作为函数返回值，就是表示该函数无返回值。通常没有返回值的函数默认是不需要在函数签名中指定返回类型的。</p><p>​        使用了let声明变量assert_eq! 则是宏语句，踏实rust提供的断言，允许判断给定的两个表达式求值结果是否相同。像这种名字以叹号结尾，并且可以像函数一样被调用的语句，在rust中叫做<strong>宏</strong>。</p><p>​        rust编译器在解析代码的时候，如果碰到分号，就会继续往后面执行；如果碰到语句，则执行语句；如果碰到表达式，则会对表达式求值，如果分号后面什么都没有，就会补上单元值（）。</p><p>​        当遇到函数的时候，会将函数体的花括号识别为块表达式 Block expression。块表达式是由一对花括号和系列表达式组成的。他总是返回块中最后一个表达式的值。</p><p>​        从这个角度看，可以讲rust看作一切皆表达式。由于当分号后面什么都没有时自动补单元值（）的特点。我们可以将rust中的语句看作计算结果均为（）的特殊表达式。而对于普通表达式来说，则会得到正常的求值结果。</p><h2 id="变量与绑定"><a href="#变量与绑定" class="headerlink" title="变量与绑定"></a>变量与绑定</h2><p>通过let关键字来创建变量，这是rust函数从函数式语言中借鉴的语法形式。let创建的变量一般称为绑定 binding。它表明了标识符 identifier 和值value 之间建立的一种关联关系。</p><h3 id="位置表达式和值表达式"><a href="#位置表达式和值表达式" class="headerlink" title="位置表达式和值表达式"></a>位置表达式和值表达式</h3><p>rust中的表达式一般分为<strong>位置表达式 place expression 和值表达式 value expression</strong>。在其他语言中，一般叫做左值 lvalue和右值rvalue。</p><p>位置表达式就是表示内存位置的表达式。分类有：</p><ul><li>本地变量</li><li>静态变量</li><li>解引用 （*epr）</li><li>数组索引（expr[expr])</li><li>字段引用（exp.field)</li><li>位置表达式组合</li></ul><p>通过位置表达式可以对某个数据单元的内存进行读写。主要进行写操作，这也是位置表达式可以被赋值的原因。</p><p>值表达式一般只引用了某个存储单元地址中的数据。它相当于数据值，只能进行读操作。</p><p>从语义角度来说，位置表达式代表了持久性数据，值表达式代表了临时数据。位置表达式一般有持久的状态，值表达式要么是自面量，要么是表达式求值过程中创建的临时值。</p><p>表达式的求值过程在不同的上下文中会有不同的结果。求值上下文也分为位置上下文 place context 和值上下文 value context。</p><p>下面几种表达式属于位置上下文：</p><ul><li>赋值或者复合赋值语句左侧的操作数。</li><li>一元引用表达式的独立操作数。</li><li>包含隐式借用（引用）的操作数。</li><li>match 判别式或者let绑定右侧在使用ref模式匹配的时候也是位置上下文。</li></ul><p>除了上述几种情况，其余表达式都属于值上下文。值表达式不能出现在位置上下文中。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">temp</span></span>() -&gt; <span class="built_in">i32</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> x = &amp;temp();</span><br><span class="line">  temp() = *x; <span class="comment">//e0070: invalid left-hand size expression</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main函数中，使用temp函数调用放到赋值语句左边的位置上下文中，此时编译器会报错。因为temp函数调用是一个无效的位置表达式，它是值表达式。</p><h3 id="不可变绑定与可变绑定"><a href="#不可变绑定与可变绑定" class="headerlink" title="不可变绑定与可变绑定"></a>不可变绑定与可变绑定</h3><p>使用let关键字声明的位置表达式默认不可变，为不可变绑定。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// a = 2; //immytable and error</span></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> b = <span class="number">2</span>;</span><br><span class="line">  b = <span class="number">3</span>; <span class="comment">// mutable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量a默认是不可变绑定，对其重新复制后编译器会报错。通过mut关键字，可以声明可变位置表达式，即可变绑定。可变绑定可以正常修改和赋值。</p><p>从语义上来说，let声明的不可变绑定只能对相应的存储单元进行读取，而let mut 声明的可变绑定则是可以对相应的存储单元进行写入。</p><h3 id="所有权与引用"><a href="#所有权与引用" class="headerlink" title="所有权与引用"></a>所有权与引用</h3><p>当位置表达式出现在值上下文中，该位置表达式将会把内存地址转移到另一个位置表达式，这是所有权的转移。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line"><span class="keyword">let</span> place1 = <span class="string">"hello"</span>;</span><br><span class="line">  <span class="keyword">let</span> place2 = <span class="string">"hello"</span>.to_string();</span><br><span class="line">  <span class="keyword">let</span> other = place1;<span class="comment">//Copy</span></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, place1); </span><br><span class="line">  <span class="keyword">let</span> other = place2;<span class="comment">// Move</span></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, place2); <span class="comment">//place2 value used here after move</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>place1是绑定的是一个字符串字面量，对于字符串字面量来说，和基本类型都一样都有Copy trait，在赋值操作时执行的是Copy操作，不回所有权的移动，现在出现在赋值操作符右侧，这里let other = place1; 会执行place1的拷贝操作，在执行之后，打印place1仍然是可以的。</p><p>而place2是String类型，没有Copy triat，这里赋值后，会发生所有权的移动。接着打印place2会出现错误，place2 value used here after move</p><p><strong>在语义上，每个变量实际上都拥有该存储单元的所有权，这种转移所有权地址的行为就是所有权ownership的转移，在rust中称为移动 move 语义。那种不转移的情况。实际是上是一种复制copy语义。Rust没有GC， 所以完全依靠所有权来管理内存管理。</strong></p><p>在日常开发中，有时并不需要转移所有权。Rust提供<strong>引用操作符&amp;</strong>， 可以直接获取表达式的存储单元地址，即内存地址。可以通过该内存位置对存储进行读取。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">  <span class="keyword">let</span> b = &amp;a;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;:p&#125;"</span>, b); <span class="comment">// 0x7fffcbc067704</span></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> c = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">  <span class="keyword">let</span> d = &amp;<span class="keyword">mut</span> c;</span><br><span class="line">  d.push(<span class="number">4</span>);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, d);<span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line">  <span class="keyword">let</span> e = &amp;<span class="number">42</span>;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="number">42</span>, *e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面定义了固定长度数组a，并使用引用操作符&amp;取得a的内存地址，赋值给b。这种方式不会引起所有权的转移，因为使用引用操作符已经将赋值表达式右侧变成了位置上下文，他只是共享内存地址。通过println! 宏指定{:p}格式，可以打印b的指针地址。也就是内存地址。</p><p>通过let mut 声明了动态长度数组c，然后通过&amp;mut 获取c的可变引用，赋值给d。</p><p><strong>注意，要获取可变引用，必须先声明可变绑定。</strong></p><p>对于字面量42来说，其本省属于值表达式。通过引用操作符，相当于值表达式在位置上下文中进行求值，所以编译器会为&amp;42创建一个临时值。</p><p>最后，通过解引用操作符*将引用e中的值取出来，以供assert_eq!宏使用。</p><p>从语义上来说，不管&amp;a还是&amp;mut c；都相当于对a和c所有权的借用，因为a和c还依旧保留他们的所有权，所以引用也被称为借用。</p><h2 id="函数与闭包"><a href="#函数与闭包" class="headerlink" title="函数与闭包"></a>函数与闭包</h2><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p>main函数，它代表程序的入口。对于二进制可执行文件来说，main函数必不可少。对于库函数来说，mian函数就没有必要。</p><p>函数是通过关键字fn定义的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">fizz_buzz</span></span>(num: <span class="built_in">i32</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> num % <span class="number">15</span> == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"fizzbuzz"</span>.to_string();</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> num % <span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"fizz"</span>.to_string();</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> num % <span class="number">5</span> == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"buzz"</span>.to_stirng();</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num.to_string();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(fizz_buzz(<span class="number">15</span>), <span class="string">"fizzbuzz"</span>.to_string());</span><br><span class="line">  <span class="built_in">assert_eq!</span>(fizz_buzz(<span class="number">3</span>), <span class="string">"fizz"</span>.to_string());</span><br><span class="line">  <span class="built_in">assert_eq!</span>(fizz_buzz(<span class="number">5</span>), <span class="string">"buzz"</span>.to_string());</span><br><span class="line">  <span class="built_in">assert_eq!</span>(fizz_buzz(<span class="number">13</span>), <span class="string">"13"</span>.to_string());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用fn关键字定义了fizz_buzz函数，其函数签名pub fn fizz_buzz(num: i32) -&gt; String 清晰地反映了函数的类型约定：传入i32类型，返回Srtring类型。<strong>Rust编译器会严格遵守此类型的契约，如果传入或返回的不是约定好的类型，则会编译时出错。</strong> </p><p>return表达式用于退出一个函数，并返回一个值。但是如果return后买呢没有值，就会默认返回单元值。</p><p>使用了to_string 方法，他将表达式的求值结果转换成Siting类型。</p><h3 id="作用域与生命周期"><a href="#作用域与生命周期" class="headerlink" title="作用域与生命周期"></a>作用域与生命周期</h3><p>Rust语言的作用域是静态作用域，即词法作用域 Lexical scope。由一对花括号来开辟作用域，其作用域在词法分析阶段就已经确定了，不回动态该改变。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> v = <span class="string">"hello world!"</span>;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(v, <span class="string">"hello world!"</span>);</span><br><span class="line">  <span class="keyword">let</span> v = <span class="string">"hello Rsut!"</span>;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(v, <span class="string">"hello Rsut!"</span>);</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="string">"hello Wolrd!"</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v, <span class="string">"hello World!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(v, <span class="string">"hello Rust!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先定义了变量绑定v，赋值为hello world！，然后通过断言验证其值。再次通过let声明变量绑定v，赋值为hello Rust！这种定义同名变量的做法叫做<strong>变量遮蔽 variable shadow</strong>。但是最终的变量v的值是由第二个变量定义所决定的。</p><p>在词法作用域内部使用花括号开辟新的词法作用域后，两个作用域是相互独立的。在不同的词法作用域内声明的变量绑定，拥有不同的生命周期 lifetime。 <strong>变量绑定的生命周期总是遵循这样的规律：从使用let声明创建变量绑定开始，到超出词法作用域的范围时结束。</strong></p><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>在rust 中，<strong>函数为一等公民</strong>。这意味，函数自身既可以作为函数的参数和返回值使用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">math</span></span>(op: <span class="function"><span class="keyword">fn</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span>, a: <span class="built_in">i32</span>, b: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">  op(a, b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">sum</span></span>(a: <span class="built_in">i32</span>, b: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">  a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">product</span></span>(a: <span class="built_in">i32</span>, b: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">  a * b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(math(sum, a, b), <span class="number">5</span>);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(math(product, a, b), <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了函数math, 其函数签名的第一个参数为fn(i32, i32) -&gt; i32 类型， 这在rust中时函数指针 fn pointer类型。</p><p>这里直接使用函数的名字作为函数指针。</p><p>函数也可以作为返回值使用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">is_true</span></span>() -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">  <span class="literal">true</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">true_maker</span></span>() -&gt; <span class="function"><span class="keyword">fn</span></span>() -&gt; <span class="built_in">bool</span> &#123; </span><br><span class="line">  is_true</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(true_maker()(), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了函数true_maker,返回fn() -&gt; bool 类型，其函数体内直接将is_true函数指针返回。注意此处也使用了函数名字作为函数指针，如果加上括号，就会调用该函数。</p><p>在main函数的断言中，true_maker()()调用相当于(true_maker() ) ()。 首先调用true_maker(), 会返回is_true函数指针；然后再调用is_true()函数，最终得到true。</p><h3 id="CTEE机制"><a href="#CTEE机制" class="headerlink" title="CTEE机制"></a>CTEE机制</h3><p>rust编译器可以像C++，拥有编译时函数执行 compile - time function execution , CTTE的能力。 </p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![feature(const_fn)]</span></span><br><span class="line"><span class="keyword">const</span> <span class="function"><span class="keyword">fn</span> <span class="title">init_len</span></span>() -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [<span class="number">0</span>; init_len()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用了const fn 来定义函数init_len, 该函数返回一个固定值5. 并且在main函数中，通过[0; N]这种形式来初始化初始值为0， 长度为N的数组，其中N时由调用函数init_len来求得的。</p><p>Rust中固定的数组必须在编译期就知道长度，否则会编译出错。所以函数init_len必须在编译器求值。这就是CTTE的能力。</p><p>使用const fn 定义的函数，必须可以确定值，不能存在歧义。与定义fn函数的区别在于， const fn 可以强制编译器在编译期执行函数。其中关键字const一般用于定义全局常量。</p><p>除了const fn，官方还在实现const generics特性。 支持const generics 特性，将可以实现类似impel &lt; T, const N: usize&gt; Foo for [T:N] {… } 的代码。可以为所有长度的数组实现trait Foo.</p><p>Rust中的CTTE是由miri来执行的。miri是一个MIR解释器，目前已经被集成到Rust编译器rustc中。rust 编译器目前可以支持的常量表达式有：字面量、元组、数组、字段结构体、枚举、只包含单行代码的块表达式、范围等。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包也叫做匿名函数。闭包的特点：</p><ul><li>可以像函数一种被调用。</li><li>可以捕获上下文环境中的自由变量。</li><li>可以自动推断输入和返回的类型。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> out = <span class="number">42</span>;</span><br><span class="line">  <span class="comment">// fn add(i:i32, j: i32) -&gt; i32 &#123; i + j + out &#125;</span></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(i: <span class="built_in">i32</span>, j: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123; i + j&#125;</span><br><span class="line">  <span class="keyword">let</span> closure_annotated = |i: <span class="built_in">i32</span>, j:<span class="built_in">i32</span>| -&gt; <span class="built_in">i32</span> &#123; i + j + out &#125;;</span><br><span class="line">  <span class="keyword">let</span> closure_inferred = |i, j| i + j + out;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="number">3</span>, add(i, j));</span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="number">45</span>, closure_annotated(i,j));</span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="number">45</span>, closure_inferrend(i,j));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包函数有一个重要的区别，就是闭包可以捕获外部变量，而函数不可以。 </p><p>闭包也可以作为函数参数和返回值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">closure_math</span></span>&lt;F: <span class="built_in">Fn</span>() -&gt; <span class="built_in">i32</span> &gt;(op: F) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">  op()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(clousre_math(|| a + b), <span class="number">5</span>);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(clousre_math(|| a * b), <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了函数closure_math,其参数是一个泛型F， 并且泛型受Fn() -&gt; i32 trait的限定，代表函数只允许实现Fn()-&gt;i32 trait的类型作为参数。</p><p><strong>Rust中闭包实际上就是一个匿名结构体和trait来组合实现的。</strong></p><p>闭包也可以作为返回值，</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">two_times_impl</span></span>() -&gt; <span class="keyword">impl</span> <span class="built_in">Fn</span>(<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">move</span> |j| j * i</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> result = two_times_impl();</span><br><span class="line">  <span class="built_in">assert_eq!</span>(result(<span class="number">2</span>), <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数定义时并不知道具体的返回类型，但是在函数调用时，编译器会推断出来。这个过程也是零成本抽象的，一切都发生在编译器。</p><p><strong>在函数two_times_imple中最后返回闭包时使用了move关键字，这是因为在一般情况下，闭包默认会岸引用捕获变量。如果将此闭包返回，则引用也会跟着返回变量i的引用，也将成为悬垂指针。使用move关键字，将捕获变量i的所有权转移到闭包中，就不会按引用进行捕获变量，这样闭包才可以安全地返回。</strong></p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>流程控制表达式</p><h3 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h3><p>表达式一定会有值，所以if表达式的分支必须返回一个类型的值才可以。if表达式的求值规则和块表达式一致。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">13</span>;</span><br><span class="line">  <span class="keyword">let</span> big_n = <span class="keyword">if</span> ( n &lt; <span class="number">10</span> &amp;&amp; n &gt; -<span class="number">10</span> )&#123;</span><br><span class="line">    <span class="number">10</span> * n</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    n / <span class="number">2</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(big_n, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环表达式"><a href="#循环表达式" class="headerlink" title="循环表达式"></a>循环表达式</h3><p>rust中包括三种循环表达式： while， loop和for … in 表达式。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">for</span> n <span class="keyword">in</span> <span class="number">1</span>..<span class="number">101</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">15</span> == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="built_in">println!</span>(<span class="string">"fizzbuzz"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> n % <span class="number">3</span> == <span class="number">0</span>&#123;</span><br><span class="line">      <span class="built_in">println!</span>(<span class="string">"fizz"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> n % <span class="number">5</span> == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="built_in">println!</span>(<span class="string">"buzz"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>For .. in 表达式本质上是一个迭代器，其中1..101 是一个range类型，它是一个迭代器。for的每一次循环都从迭代器中取值，当迭代器中没有值的时候，for循环结束。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">while_true</span></span>(x: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> <span class="literal">true</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> y = while_true(<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(y, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中while循环条件使用了硬编码true，目的是实现无限循环。这种看似非常正确的代码会引起rust编译器报错。</p><p>错误提示称while true 循环块返回的是单元值，而函数while_true返回值是i32， 所以不匹配。但是在while true 循环中使用了return关键字，应该返回i32类型才行。为什么会报错呢？</p><p>这是因为rust编译器在对while循环做流分析 Flow sensitive 的时候，不会检查循环条件，编译器会认为while循环条件可真可假，所以循环体里的表达式也会被忽略，此时编译器只知道while true 循环返回的是单元值，而函数返回的是i32。其他情况一概不知。这一切都是因为CTEE功能的限制，while条件表达式无法作为编译器常量来使用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">while_true</span></span>(x: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> <span class="literal">true</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在while_true函数的最后一行加了x变量，这是为了让编译器以为返回的类型是i32类型，但实际上，程序在运行以后，将永远在while true 循环汇中执行。</p><h3 id="match-表达式与模式匹配"><a href="#match-表达式与模式匹配" class="headerlink" title="match 表达式与模式匹配"></a>match 表达式与模式匹配</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> number = <span class="number">42</span>;</span><br><span class="line">  <span class="keyword">match</span> number &#123;</span><br><span class="line">    <span class="number">0</span> =&gt; <span class="built_in">println!</span>(<span class="string">"Origin"</span>),</span><br><span class="line">    <span class="number">1</span>...<span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">"All"</span>),</span><br><span class="line">    |<span class="number">5</span>|<span class="number">7</span>|<span class="number">13</span> =&gt; <span class="built_in">println!</span>(<span class="string">"Bad luck"</span>),</span><br><span class="line">    n @ <span class="number">42</span> =&gt; <span class="built_in">println!</span>(<span class="string">"Answer is &#123;&#125;"</span>, n),</span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">"Common"</span>),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在rust语言中，match分支使用了模式匹配 pattern matching 技术。模式匹配在数据结构字符串中经常出现，比如在某个字符串中找出与该字符串相同的所有子串。在编程语言中，模式匹配用于判断类型或者值是否存在可以匹配的模式。模式匹配在很多函数式语言中已经被广泛应用。</p><p>在rust语言中，match分支左边就是模式，右边就是执行代码。模式匹配同时也是一个表达式，与if表达式类似，所有分支必须返回一个类型。但是左侧的模式可以是不同的。</p><p>使用操作符@可以将模式中的值绑定给一个变量。供分支右侧的代码使用，这类匹配叫做绑定模式 Bindingmode。match表达式必须穷尽每一种可能，所以一般情况下会使用通配符_来处理剩余的情况。</p><h3 id="if-let-和-while-let表达式"><a href="#if-let-和-while-let表达式" class="headerlink" title="if let 和 while let表达式"></a>if let 和 while let表达式</h3><p>rust还提供了if let 和while let表达式，分别来在某些场合替代match表达式。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> boolean = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> binary = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">true</span> = boolean &#123;</span><br><span class="line">    binary = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(binary, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if let 左侧为模式，右侧为要匹配的值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">  <span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> v.pop() &#123;</span><br><span class="line">      <span class="literal">Some</span>(x) =&gt; <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x),</span><br><span class="line">      <span class="literal">None</span> =&gt; <span class="keyword">break</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用v的pop方法返回Option类型，所以用match匹配两种情况，Some(x)和None， Rust中引入Option类型是为了防止空指针的出现。Some(x)用于匹配数组中的元素，而None用于匹配数组被取空的情况。当数组为空时，就从循环中跳出。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">  <span class="keyword">while</span> <span class="keyword">let</span> <span class="literal">Some</span>(x) = v.pop() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">let</span> y: <span class="built_in">bool</span> = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">5</span>; <span class="comment">//变量遮蔽</span></span><br><span class="line">  <span class="keyword">if</span> x &gt; <span class="number">1</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"x is bigger than 1"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(x <span class="keyword">as</span> <span class="built_in">i32</span>, <span class="number">1</span>); <span class="comment">// 5 ！= 1</span></span><br><span class="line">  <span class="built_in">assert_eq!</span>(y <span class="keyword">as</span> <span class="built_in">i32</span>, <span class="number">0</span>); <span class="comment">// 0 == 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于第一个x的绑定，rust可以自动推断器类型为bool。</p><p>任意一个比较操作都会产生bool类型。</p><p>可以通过as操作符将bool类型转换成数组0或者1， 但注意的是，Rust并不知耻将数字转换成bool类型。</p><h3 id="基本数据类型-1"><a href="#基本数据类型-1" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>rust提供的基本数据类型大致分为：固定大小的类型、动态大小的类型和浮点数。</p><ul><li><p>固定大小的类型包括无符号整数 unsigned integer 和符号整数 signed integer。</p><ul><li>其中无符号整数包括：<ul><li>u8，  占用1个字符。u8类型通常在rust中表示字节序列。在文件io或者网络IO中读取数据流时需要使用u8。</li><li>u16，占用2个字节</li><li>u32，占用4个字节</li><li>U64， 占用8个字节</li><li>u128， 占用16个字节</li></ul></li><li>符号整数：<ul><li>i8，占用1个字节</li><li>I6， 占用2个字节</li><li>I32， 占用4个字节</li><li>i64，占用8个字节</li><li>I128，占用16个字节</li></ul></li><li>动态大小类型：<ul><li>usize， 占用4个或者8个字节，取决于机器的字长。</li><li>isize， 占用4个或者8个字节，取决于机器的字长。</li></ul></li><li>浮点数类型：<ul><li>F32， 单精度32位浮点数， 至少6位有效数字。</li><li>F64， 单精度64位浮点数，至少15位有效数字。</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> num = <span class="number">42u32</span>;</span><br><span class="line">  <span class="keyword">let</span> num : <span class="built_in">u32</span> = <span class="number">42</span>;</span><br><span class="line">  <span class="keyword">let</span> num = <span class="number">0x2A</span>; </span><br><span class="line">  <span class="keyword">let</span> num = <span class="number">0o106</span>;</span><br><span class="line">  <span class="keyword">let</span> num = <span class="number">0b1101_1011</span>;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="string">b'*'</span>, <span class="number">42u8</span>);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="string">b'\''</span>, <span class="number">39u8</span>);</span><br><span class="line">  <span class="keyword">let</span> num = <span class="number">3.1415926f64</span>;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(-<span class="number">3.14</span>, -<span class="number">3.14f64</span>);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="number">2</span>., <span class="number">2.0f64</span>);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="number">2e4</span>, <span class="number">20000f64</span>);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, std::<span class="built_in">f32</span>::INFINITY);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, std::<span class="built_in">f32</span>::NEG_INFINITY);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, std::<span class="built_in">f32</span>::NAN);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, stf::<span class="built_in">f32</span>::MIN);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, std::<span class="built_in">f32</span>::MAX);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rust中可以写字节字面量， 比如以b开头的字符b’*’ ,它实际等价于42u8</p></li></ul><h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><p>在rust中，使用单引号来定义字符类型。字符类型代表的是一个unicode标量，每个字符占4个字节。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> x= <span class="string">'r'</span>;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="string">'U'</span>;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="string">'\''</span>);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="string">'\\'</span>);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="string">'\n'</span>);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="string">'\r'</span>);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="string">'\t'</span>);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="string">'\x2A'</span>, <span class="string">'*'</span>);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="string">'\x25'</span>, <span class="string">'%'</span>);</span><br><span class="line">  <span class="built_in">assert_eq!</span>('\u&#123;CA0&#125;', <span class="string">'8'</span>);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="string">'%'</span> <span class="keyword">as</span> <span class="built_in">i8</span>, <span class="number">37</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><p>数组array时rust内建的原始集合类型，数组的特点：</p><ul><li>数组大小固定。</li><li>元素均为同类型。</li><li>默认不可变。</li></ul><p>数组的类型签名位[T;N].T是一个泛型标记。代表数组中元素的某个具体类型。N代表数组的长度，是一个编译时常量，必须在编译时确定其值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> arr: [<span class="built_in">i32</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> mut_arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="number">1</span>, mut_arr[<span class="number">0</span>]);</span><br><span class="line">  mut_arr[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="number">3</span>, mut_arr[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">let</span> init_arr = [<span class="number">0</span>; <span class="number">10</span>];</span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="number">0</span>, init_arr[<span class="number">5</span>]);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="number">10</span>, init_arr.len());</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, arr[<span class="number">5</span>]);<span class="comment">// Error: index out of bounds</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于原始固定长度数组，只有实现Copy trait的类型才能作为其元素。也就是说，只有可以在栈上存放的元素才可以存放在该类型的数组中。Rust还将支持VLA variable length array数组， 即可变长数组。对于可变长数组，将会基于可以在栈上动态分配内存的函数来实现。</p><h3 id="范围类型"><a href="#范围类型" class="headerlink" title="范围类型"></a>范围类型</h3><p>Rust内置来范围Range类型，包活左闭右开和全闭两种区间。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="built_in">assert_eq!</span>((<span class="number">1</span>..<span class="number">5</span>), std::ops::Range(start: <span class="number">1</span>, end: <span class="number">5</span>));</span><br><span class="line">  <span class="built_in">assert_eq!</span>((<span class="number">1</span>..=<span class="number">5</span>), std::ops::RangeInclusive::new(<span class="number">1</span>, <span class="number">5</span>));</span><br><span class="line"> <span class="built_in">assert_eq!</span>(<span class="number">3</span>+<span class="number">4</span>+<span class="number">5</span>, (<span class="number">3</span>..<span class="number">6</span>).sum());</span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="number">3</span>+<span class="number">4</span>+<span class="number">5</span>+<span class="number">6</span>, (<span class="number">3</span>..=<span class="number">6</span>).sum());</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">5</span>)&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> (<span class="number">1</span>..=<span class="number">5</span>)&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个范围都是一个迭代器， 可以直接使用for循环打印。</p><h3 id="切片类型"><a href="#切片类型" class="headerlink" title="切片类型"></a>切片类型</h3><p>切片slice类型是对一个数组（包括固定大小数组和动态数组）的引用片段，有利于安全有效地访问数组的一部分，而不需要拷贝。</p><p>因为理论上，切片引用的是已经存在的变量。在底层，切片代表一个指向数组起始位置的指针和数组长度。用[T]类型表示连续序列，那么切片类型就是&amp;[T]和&amp;mut[T].</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> arr : [<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">  <span class="built_in">assert_eq!</span>(&amp;arr, &amp;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(&amp;arr[..], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(&amp;arr.len(), &amp;<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(&amp;arr.is_empty(), &amp;<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">let</span> arr = &amp;<span class="keyword">mut</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">  arr[<span class="number">1</span>] = <span class="number">7</span>;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(arr, &amp;[<span class="number">1</span>, <span class="number">7</span>, <span class="number">3</span>]);</span><br><span class="line">  <span class="keyword">let</span> vec = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">  <span class="built_in">assert_eq!</span>(&amp;vec[..], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过引用操作符&amp;对数组进行引用，就产生了一个切片&amp;arr，也可以结合范围对数组进行切割，比如&amp;arr[1..], 表示获取arr数组中在索引位置1之后的所有元素。</p><p>切片提供了两个const fn 方法，len和is_empty,分别用来得到切片的长度和判断切片是否为空。</p><p>通过&amp;mut可以定义可变切片，这个样可以直接通过索引来修改相应位置的值。</p><p>对于使用vec!宏定义的数组，也可以通过引用操作符来得到一个切片。</p><h3 id="str字符串类型"><a href="#str字符串类型" class="headerlink" title="str字符串类型"></a>str字符串类型</h3><p>Rust提供了原始的字符串类型str，也叫做字符串切片。它通常以不可变借用的形式存在，即&amp;str。出于安全的考虑，Rust将字符串分成两种类型。一种是固定长度字符串，不可随便更改其长度类型，就是str字符串；另一种是可增长字符串，可以随意改变其长度，就是String字符串。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> truth: &amp;<span class="symbol">'static</span> <span class="built_in">str</span> = <span class="string">"Rust is a system programming language"</span>;</span><br><span class="line">  <span class="keyword">let</span> ptr = truth.as_ptr();</span><br><span class="line">  <span class="keyword">let</span> len = truth.len();</span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="number">28</span>, len);</span><br><span class="line">  <span class="keyword">let</span> s = <span class="keyword">unsafe</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> slice = std::slice::from_raw_parts(ptr, len);</span><br><span class="line">    std::<span class="built_in">str</span>::from_utf8(slice);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(s, <span class="literal">Ok</span>(truth));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串字面量也属于str类型，只不过它是静态生命周期字符床&amp;’static str.所谓静态生命周期，可以理解为该类型字符串和程序代码一样是持久有效的。</p><p>str字符串类型由两部分组成：指向字符串序列的指针和记录长度的值。可以通过str模块提供的as_ptr和len方法分别求得指针和长度。</p><p>Rust中字符串本质上是一段有效的UTF8字节序列。所以可以将一段字节序列转换成str字符串。</p><p>通过std::slice::from_raw_parts函数，传入指针和长度，可以将相应的字节序列转换为切片类型&amp;[u8].再使用std::str::from_utf8函数将得到的切片转换成str字符串。因为整个过程中并没有验证字节序列是否为合法的utf8字符串，所以需要放到unsafe块中执行整个转换过程。</p><h3 id="原生指针"><a href="#原生指针" class="headerlink" title="原生指针"></a>原生指针</h3><p>将表示内存地址的类型成为指针。Rust提供了多种类型的指针，包括引用 Reference、原生指针 Raw pointer、函数指针</p><p>和智能指针 smart Pointer</p><p>引用，本质上是一种非空指针。Rust可以划分为Safe Rust 和Unsafe Rust。引用主要用于Safe Rust中，在Safe Rsut中，编译器会对引用进行借用检查，以保证内存安全和类型安全。</p><p>原生类型主要用于Unsafe Rust中。直接使用原生指针是不安全的，比如原生指针可能指向一个null，或者一个已经释放的内存区域，因为使用原生指针的地方不再Safe Rust的可控范围内，所以需要程序员自己保证安全。Rust支持两种原生指针：不可变原生指针 * const T和可变原生指针 * mut T。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">let</span> ptr _x = &amp;<span class="keyword">mut</span> x <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">i32</span>;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="built_in">Box</span>::new(<span class="number">20</span>);</span><br><span class="line">  <span class="keyword">let</span> ptr_y = &amp;*y <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">i32</span>;</span><br><span class="line">  <span class="keyword">unsafe</span> &#123;</span><br><span class="line">    *ptr_x += *ptr_y;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(x, <span class="number">30</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过as操作符将&amp;mut x可变引用转换成* mut i32可变原生指针 ptr-x</p><p>使用Box::new(20) 代表在堆内存上存储数字20，然后通过一系列操作转成不可变原生指针ptr_y</p><p>注意操作原生指针要使用unsafe块。</p><h3 id="never类型"><a href="#never类型" class="headerlink" title="never类型"></a>never类型</h3><p>Rust 中提供了一种特殊数据类型，never类型，即！。该类型用于表示永远不可能有返回值的计算类型，比如线程退出的时候，就不可能有返回值，Rust是一个类型安全的语言，所以这也需要将这种情况纳入类型系统中进行统一管理。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![feature(never_type)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>() -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> x: ! = &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> num : <span class="built_in">Option</span>&lt;<span class="built_in">u32</span>&gt; = <span class="literal">Some</span>(<span class="number">42</span>);</span><br><span class="line">  <span class="keyword">match</span> num &#123;</span><br><span class="line">    <span class="literal">Some</span>(num) =&gt; num,</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">panic!</span>(<span class="string">"Nothing!"</span>),</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用#![feature(never_type)]特性，这是因为当前never类型属于实验特性。</p><p>定义的foo函数，其内部定义的绑定x指定啦never类型，右侧块中使用了return表达式。因为return表达式会将123返回，绑定x永远都不会被赋值，所以这里使用never类型不会出现编译错误。与return表达式类似的还有break和continue。</p><h3 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h3><p>Rust提供来4中复合数据类型：</p><ul><li>元组 tuple</li><li>结构体 struct</li><li>枚举体 enum</li><li>联合体 union</li></ul><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>元组 truple 是一种异构有限序列，形如（T， U， M， N）。所谓异构，就是指元组内的元素可以是不同的类型；所谓有限，是指元组有固定的长度。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">move_coords</span></span>(x: (<span class="built_in">i32</span>, <span class="built_in">i32</span>)) -&gt; (<span class="built_in">i32</span>, <span class="built_in">i32</span>)&#123;</span><br><span class="line">  (x.<span class="number">0</span> + <span class="number">1</span>, x.<span class="number">1</span> + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> tuple : (&amp;<span class="symbol">'static</span> <span class="built_in">str</span>, <span class="built_in">i32</span>, <span class="built_in">char</span>) = (<span class="string">"hello"</span>, <span class="number">5</span>, <span class="string">'c'</span>);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(tuple.<span class="number">0</span>, <span class="string">"hello"</span>);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(tuple.<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(tuple.<span class="number">2</span>, <span class="string">'c'</span>);</span><br><span class="line">  <span class="keyword">let</span> coords = (<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> result = move_coords(coords);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(result, (<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">  <span class="keyword">let</span> (x, y) = move_coords(coords);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(x, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(y, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过索引来获取元组内元素的值，</p><p>利用元组也可以让函数返回多个值。</p><p>因为let支持模式匹配，所以可以用来结构元组。</p><p>当元组中只有一个值的时候，需要加逗号，即（0，）这是为了和括号中其他值进行区分，其他值形如（0）。实际上单元类型就是一个空元组（）。</p><h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><p>rust提供了三种结构体：</p><ul><li>具名结构体 Named filed struct</li><li>元组结构体 tuple like struct</li><li>单元结构体 unit like struct</li></ul><p>具名结构体是最常见的结构体</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, PartialEq)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">People</span></span>&#123;</span><br><span class="line">  name: &amp;<span class="symbol">'static</span> <span class="built_in">str</span>,</span><br><span class="line">  gender: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> People &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(name: &amp;<span class="symbol">'static</span> <span class="built_in">str</span>, gender: <span class="built_in">u32</span>) -&gt; <span class="keyword">Self</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> People(name: name, gender: gender);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">name</span></span>(&amp;<span class="keyword">self</span>)&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"name: &#123;:?&#125;"</span>, <span class="keyword">self</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">set_name</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, name: &amp;<span class="symbol">'static</span> <span class="built_in">str</span>)&#123;</span><br><span class="line">    <span class="keyword">self</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">gender</span></span>(&amp;<span class="keyword">self</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> gender = <span class="keyword">if</span> (<span class="keyword">self</span>.gender == <span class="number">1</span>)&#123;</span><br><span class="line">      <span class="string">"body"</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="string">"girl"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"gender: &#123;:?&#125;"</span>, gender);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意结构体名称要遵守驼峰命名规则，</p><p>结构体里面字段格式为name： type， name是字段的名称，type是此字段的类型，所以此类结构体为具名结构体。结构体中字段默认不可变，而且字段可以是任意类型的，甚至是结构体本身。</p><p>People机构体上方的#[derive(Debug, PartialEq)]是属性，可以让结构体自动实现Debug trait和partialEq trait，他们的功能是允许对结构体实例进行打印和比较。</p><p>在rust中，函数和方法是有区别的。如果不是impl块里定义的函数，就是自由函数。而在impl块中定义的函数被称为方法。这个面向对象有点渊源。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> alex = People::new(<span class="string">"Alex"</span>, <span class="number">1</span>);</span><br><span class="line">  alex.name();</span><br><span class="line">  alex.gender();</span><br><span class="line">  <span class="built_in">assert_eq!</span>(alex, People&#123;name: <span class="string">"Alex"</span>, gender: <span class="number">1</span>&#125;);</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> alice  = People::new(<span class="string">"Alice"</span>, <span class="number">0</span>);</span><br><span class="line">  alice.name();</span><br><span class="line">  alice.gender();</span><br><span class="line">  <span class="built_in">assert_eq!</span>(alice, People&#123;name: <span class="string">"Alice"</span>, gender: <span class="number">0</span>&#125;);</span><br><span class="line">  alice.set_name(<span class="string">"Rose"</span>);</span><br><span class="line">  alice.name();</span><br><span class="line">  <span class="built_in">assert_eq!</span>(alice, People&#123;name: <span class="string">"Rose"</span>, gender: <span class="number">0</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rust具名结构体是面向对象思想的一种体现。</p><p>Rust还有一种结构体，看起来像元组和具名结构体的混合体，叫做元组结构体，特点是，字段没有名称，只有类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>);</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> color = Color(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(color.<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(color.<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(color.<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意的是， 元组结构体后面要加分号。元组结构体访问字段的方式和元组一样，也是使用圆点记号按位置索引访问。</p><p>当一个元组结构体只有一个字段的时候，称之为New type模式。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Integer</span></span>(<span class="built_in">u32</span>);</span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Int</span></span> = <span class="built_in">i32</span>;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line"><span class="keyword">let</span> int = Integer(<span class="number">10</span>);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(int.<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">let</span> int: Int = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(int, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之所以称为New type模式，是因为相当于把u32类型包装成了新的Integer类型。</p><p>也可以使用type关键字为一个类型创建别名，但是这个本质上Int还是i32类型，所拥有的行为和i32一样。</p><p>New Type属于自定义类型，更加灵活。</p><p>Rust中可以定义一个没有任何字段的结构体，即单元结构体。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Empty</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> x = Empty;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;:p&#125;"</span>, &amp;x);</span><br><span class="line">  <span class="keyword">let</span> y = x;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;:p&#125;"</span>, &amp;y);</span><br><span class="line">  <span class="keyword">let</span> z = Empty;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;:p&#125;"</span>, &amp;z);</span><br><span class="line">  <span class="built_in">assert_eq!</span>((..), std::ops::RangeFull);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义的Empty结构体，等价于struct Empty {}; 单元结构体实例就是本身，</p><p>为同一个单元结构体创建多个实例，这些实例是否是同一个对象？此处的对象是广义层的，并非面向对象中的对象。</p><h4 id="枚举体"><a href="#枚举体" class="headerlink" title="枚举体"></a>枚举体</h4><p>枚举体 也可以称为枚举类型或枚举，该类型包含了全部可能的情况，可以有效地防止用户提供无效值。在rust中，枚举可以使用enum关键字来定义，并有三种形式，其中一种是无参数枚举体。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Number</span></span> &#123;</span><br><span class="line">  Zero,</span><br><span class="line">  One,</span><br><span class="line">  Two,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> a = Number::One;</span><br><span class="line">  <span class="keyword">match</span> a &#123;</span><br><span class="line">    Number::Zero =&gt; <span class="built_in">println!</span>(<span class="string">"0"</span>),</span><br><span class="line">    Number::One =&gt; <span class="built_in">println!</span>(<span class="string">"1"</span>),</span><br><span class="line">    Number::Two =&gt; <span class="built_in">println!</span>(<span class="string">"2"</span>),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main函数中要使用枚举值，需要使用Number前缀，可以使用match匹配来枚举所有的值，来处理相应的情况。</p><p>Rust也可以像C中那种形式的枚举体。类C枚举体。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span></span> &#123;</span><br><span class="line">  Red = <span class="number">0xff0000</span>,</span><br><span class="line">  Green = <span class="number">0x00ff00</span>,</span><br><span class="line">  Blue = <span class="number">0x0000ff</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"roses are #&#123;:06x&#125;"</span>, Color::Read <span class="keyword">as</span> <span class="built_in">i32</span>);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"violets are #&#123;:06x&#125;"</span>, Color::Blue <span class="keyword">as</span> <span class="built_in">i32</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rust还支持携带类型参数的枚举体</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddr</span></span> &#123;</span><br><span class="line">  V4(<span class="built_in">u8</span>, <span class="built_in">u8</span>, <span class="built_in">u8</span>, <span class="built_in">u8</span>),</span><br><span class="line">  V6(<span class="built_in">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> x : <span class="function"><span class="keyword">fn</span></span>(<span class="built_in">u8</span>, <span class="built_in">u8</span>, <span class="built_in">u8</span>, <span class="built_in">u8</span>) -&gt; IpAddr = IpAddr::V4;</span><br><span class="line">  <span class="keyword">let</span> y: <span class="function"><span class="keyword">fn</span></span>(<span class="built_in">String</span>) -&gt; IpAddr = IpAddr::V6;</span><br><span class="line">  <span class="keyword">let</span> home = IpAddr::V4(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其枚举值携带来类型参数，这样的枚举值本质上属于函数指针类型。</p><p>使用该枚举值就像函数调用那样，需要传入实际的参数。</p><p>枚举在Rust中属于非常重要的类型之一，为编程提供了很多方便， 保证了Rust中避免出现空指针。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">  <span class="literal">Some</span>(<span class="built_in">i32</span>),</span><br><span class="line">  <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> s = <span class="literal">Some</span>(<span class="number">42</span>);</span><br><span class="line">  <span class="keyword">let</span> num = s.unwrap();</span><br><span class="line">  <span class="keyword">match</span> s &#123;</span><br><span class="line">   <span class="literal">Some</span>(n) =&gt; <span class="built_in">println!</span>(<span class="string">"num is : &#123;&#125;"</span>, n),</span><br><span class="line">    <span class="literal">None</span> =&gt; (),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用集合类型"><a href="#常用集合类型" class="headerlink" title="常用集合类型"></a>常用集合类型</h2><p>rust标准库std::collections模块下有4种通用集合类型，</p><ul><li><p>线性序列： 向量vec， 双端队列vecDeque， 链表linkedlist</p></li><li><p>Key-value映射表：无序哈希表hashmap， 有序哈希表Btreemap</p></li><li><p>集合类型：无序集合hashset， 有序集合btreeset</p></li><li><p>优先队列：二叉堆BinaryHeap</p></li></ul><h3 id="线性表：-向量"><a href="#线性表：-向量" class="headerlink" title="线性表： 向量"></a>线性表： 向量</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> v1 = <span class="built_in">vec!</span>[];</span><br><span class="line">  v1.push(<span class="number">1</span>);</span><br><span class="line">  v1.push(<span class="number">2</span>);</span><br><span class="line">  v1.push(<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(v1, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(v1[<span class="number">1</span>], <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> v2 = <span class="built_in">vec!</span>[<span class="number">0</span>;<span class="number">10</span>];</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> v3 = <span class="built_in">Vec</span>::new();</span><br><span class="line">  v3.push(<span class="number">4</span>);</span><br><span class="line">  v3.push(<span class="number">5</span>);</span><br><span class="line">  v3.push(<span class="number">6</span>);</span><br><span class="line">  v3[<span class="number">4</span>];<span class="comment">// error: index out of bounds</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rust 对向量和数组都会做越界检查，来保证安全。</p><h3 id="线性序列：-双端队列"><a href="#线性序列：-双端队列" class="headerlink" title="线性序列： 双端队列"></a>线性序列： 双端队列</h3><p>双端队列 double ended queue，是一种同时具有队列和栈性质的数据结构。</p><p>rust中的VecDequeue是基于可增长的ringbuffer算法实现的双端队列。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::VecDeque;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> buf = VecDeque::new();</span><br><span class="line">  buf.push_front(<span class="number">1</span>);</span><br><span class="line">  buf.push_front(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(buf.get(<span class="number">0</span>), <span class="literal">Some</span>(&amp;<span class="number">2</span>));</span><br><span class="line">  <span class="built_in">assert_eq!</span>(buf.get(<span class="number">1</span>), <span class="literal">Some</span>(&amp;<span class="number">1</span>));</span><br><span class="line">  buf.push_back(<span class="number">3</span>);</span><br><span class="line">  buf.push_back(<span class="number">4</span>);</span><br><span class="line">  buf.push_bacl(<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(buf.get(<span class="number">2</span>), <span class="literal">Some</span>(&amp;<span class="number">3</span>));</span><br><span class="line">  <span class="built_in">assert_eq!</span>(buf.get(<span class="number">3</span>), <span class="literal">Some</span>(&amp;<span class="number">4</span>));</span><br><span class="line">  <span class="built_in">assert_eq!</span>(buf.get(<span class="number">4</span>), <span class="literal">Some</span>(&amp;<span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过get方法加索引值可以获取队列中相应的值。</p><h3 id="线性序列：-链表"><a href="#线性序列：-链表" class="headerlink" title="线性序列： 链表"></a>线性序列： 链表</h3><p>rust提供的链表是双向链表，允许在任意一段插入或弹出元素。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::LinkedList;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> list1 = LinkedList::new();</span><br><span class="line">  list1.push_back(<span class="string">'a'</span>);</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> list2 = LinkedList::new();</span><br><span class="line">  list2.push_back(<span class="string">'b'</span>);</span><br><span class="line">  list3.push_back(<span class="string">'c'</span>);</span><br><span class="line">  list1.apped(&amp;<span class="keyword">mut</span> list2);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;:p&#125;"</span>, list1); <span class="comment">//['a','b','c']</span></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;:p&#125;"</span>, list2); <span class="comment">//[]</span></span><br><span class="line">  list1.pop_front();</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;:p&#125;"</span>, list1);<span class="comment">//['b','c']</span></span><br><span class="line">  list1.push_front(<span class="string">'e'</span>);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;:p&#125;"</span>, list1);<span class="comment">//['e', 'b','c']</span></span><br><span class="line">  list2.push_front(<span class="string">'f'</span>);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;:p&#125;"</span>,list2);<span class="comment">//['f']</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Key-value-映射表：HashMap和BTreeMap"><a href="#Key-value-映射表：HashMap和BTreeMap" class="headerlink" title="Key-value 映射表：HashMap和BTreeMap"></a>Key-value 映射表：HashMap和BTreeMap</h3><p>Rust集合模块提供了两个Key value哈希映射表：</p><ul><li>HashMap&lt;K,V&gt;</li><li>BTreeMap&lt;K,V&gt;</li></ul><p>Key必须是可哈希的类型，value必须在编译期间已知大小的类型。这两种类型的区别， HashMap是无序的，BtreeMap是有序的，</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::BTreeMap;</span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> hmap = HashMap::new();</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> bmap = BTreeMap::new();</span><br><span class="line">  hmap.insert(<span class="number">3</span>, <span class="string">"c"</span>);</span><br><span class="line">  hmap.insert(<span class="number">1</span>, <span class="string">"a"</span>);</span><br><span class="line">  hmap.insert(<span class="number">2</span>, <span class="string">"b"</span>);</span><br><span class="line">  hmap.insert(<span class="number">5</span>, <span class="string">"e"</span>);</span><br><span class="line">  hmap.insert(<span class="number">4</span>, <span class="string">"d"</span>);</span><br><span class="line">  bmap.insert(<span class="number">3</span>, <span class="string">"c"</span>);</span><br><span class="line">  bmap.insert(<span class="number">2</span>, <span class="string">"b"</span>);</span><br><span class="line">  bmap.insert(<span class="number">1</span>, <span class="string">"a"</span>);</span><br><span class="line">  bmap.insert(<span class="number">5</span>, <span class="string">"e"</span>);</span><br><span class="line">  bmap.insert(<span class="number">4</span>, <span class="string">"d"</span>);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;:p&#125;"</span>, hmap);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;:p&#125;"</span>, bmap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="集合HashSet和BTreeSet"><a href="#集合HashSet和BTreeSet" class="headerlink" title="集合HashSet和BTreeSet"></a>集合HashSet和BTreeSet</h3><p>特点：</p><ul><li>集合中元素应该是唯一的，因为是Key-value映射表的key</li><li>集合中元素应该都是可哈希的类型</li><li>HashSet应该是无序的，BtreeSet应该是有序的</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashSet;</span><br><span class="line"><span class="keyword">use</span> std::collections::BTreeSet;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> hbooks = HashSet::new();</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> bbooks = BTreeSet::new();</span><br><span class="line">  hbooks.insert(<span class="string">"A song of Ice and Fire"</span>);</span><br><span class="line">  hbooks.insert(<span class="string">"The Odyssey"</span>);</span><br><span class="line">  <span class="keyword">if</span> !hbooks.contains(<span class="string">"The Emerald City"</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"We have &#123;&#125; book, but The Emerald City ain't one"</span>, hbooks.len());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;:p&#125;"</span>m hbooks);</span><br><span class="line">  bbooks.insert(<span class="string">"A Song of Ice anf Fire"</span>);</span><br><span class="line">  bbooks.insert(<span class="string">"The Emerald City"</span>);</span><br><span class="line">  bbooks.insert(<span class="string">"The Odyssey"</span>);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, bbooks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优先队列：-BinaryHeap"><a href="#优先队列：-BinaryHeap" class="headerlink" title="优先队列： BinaryHeap"></a>优先队列： BinaryHeap</h3><p>rust提供的优先队列是基于二叉最大堆实现的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::BinaryHeap;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> heap = BinaryHeap::new();</span><br><span class="line">  <span class="built_in">assert_eq!</span>(heap.peek(), <span class="literal">None</span>);</span><br><span class="line">  <span class="keyword">let</span> arr = [<span class="number">93</span>, <span class="number">80</span>, <span class="number">53</span>, <span class="number">73</span>, <span class="number">39</span>, <span class="number">36</span>, <span class="number">15</span>, <span class="number">35</span>, <span class="number">45</span>];</span><br><span class="line">  <span class="keyword">for</span> &amp;i <span class="keyword">in</span> arr.iter()&#123;</span><br><span class="line">    heap.push(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(heap.peek(), <span class="literal">Some</span>(&amp;<span class="number">93</span>));</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;:p&#125;"</span>, heap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Peek方法可以取出堆中的最大值。</p><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>智能指针 Smart pointer的功能并非rust独有的，源自C++，Rust将其引入并使之成为rust语言中最重要的一种数据结构。</p><p>rust中的值类型被分配到栈内存，可以通过Box<T>将值装箱（在堆内存中分配）。Box<T>是指向类型为T的堆内存分配的智能指针。当Box<T>超出作用域范围，将调用其析构函数，销毁内部对象，并自动释放堆中的内存。可以通过解引用操作符来获取Box<T>中的T。</p><p>Box<T>的行为像引用，并且可以自动释放内存，所以称其为智能指针。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="meta">#[derive(PartialEq)]</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">    x: <span class="built_in">f64</span>,</span><br><span class="line">    y: <span class="built_in">f64</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> box_point = Point::new(Point&#123;x: <span class="number">0.0</span>, y: <span class="number">0.0</span>&#125;);</span><br><span class="line">  <span class="keyword">let</span> unboxed_point: Point = *box_point;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(unboxed_point, Point&#123;x: <span class="number">0.0</span>, y: <span class="number">0.0</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Box<T>，开发者可以方便无痛的使用堆内存，并且无须手工释放堆内存，可以确保内存安全。</p><h2 id="泛型和trait"><a href="#泛型和trait" class="headerlink" title="泛型和trait"></a>泛型和trait</h2><p>泛型和trait是rust类型系统中最重要的两个概念。</p><p>trait不是rust独有的概念，借鉴了haskell的typeclass，trait是rust实现零成本抽象的基石，</p><ul><li>trait是rust唯一的接口抽象方式</li><li>可以静态生成，也可以动态生成</li><li>可以当作标记类型拥有某些特定行为的标签来使用。</li></ul><p>trait是对类型行为的抽象。</p><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::<span class="built_in">Debug</span>;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">match_option</span></span>&lt;T: <span class="built_in">Debug</span>&gt;(o: <span class="built_in">Option</span>&lt;T&gt;) &#123;</span><br><span class="line">  <span class="keyword">match</span> o &#123;</span><br><span class="line">    <span class="literal">Some</span>(i) =&gt; <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, i),</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">"nothing"</span>),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> a : <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; = <span class="literal">Some</span>(<span class="number">3</span>)l</span><br><span class="line">  <span class="keyword">let</span> b : <span class="built_in">Option</span>&lt;&amp;<span class="built_in">str</span>&gt; = <span class="literal">Some</span>(<span class="string">"hello"</span>);</span><br><span class="line">  <span class="keyword">let</span> c : <span class="built_in">Option</span>&lt;<span class="built_in">char</span>&gt; <span class="literal">Some</span>(<span class="string">'A'</span>);</span><br><span class="line">  <span class="keyword">let</span> d : <span class="built_in">Option</span>&lt;<span class="built_in">u32</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">  match_option(a);<span class="comment">//3</span></span><br><span class="line">  match_option(b);<span class="comment">//"hello"</span></span><br><span class="line">  match_option(c);<span class="comment">//'A'</span></span><br><span class="line">  match_option(d);<span class="comment">// nothing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义的match_option泛型函数，此处&lt;T: Debug&gt; 是增加了trait限定的泛型，即，只有实现了Debug trait的类型才适用。只有实现了Debug trait的类型才拥有”{:P}”格式化打印的行为。</p><h3 id="trait"><a href="#trait" class="headerlink" title="trait"></a>trait</h3><p>trait和类型的行为有关，</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Duck</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pig</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Fly</span></span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">fly</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> Fly <span class="keyword">for</span> Duck &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">fly</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> Fly <span class="keyword">for</span> Pig &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">fly</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fly_static</span></span>&lt;T: Fly&gt; (s: T) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">  s.fly();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fly_dyn</span></span>(s: &amp;Fly) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">  s.fly();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> pig = Pig;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(flay_static::&lt;Pig&gt;(pig), <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">let</span> duck = Duck;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(flay_static::&lt;Duck&gt;(duck), <span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(flay_dyn(&amp;Pig), <span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(flay_dyn(&amp;Duck), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在rust中trait是唯一的接口抽象方式，使用trait可以让不同的类型实现同一种行为，也可以为类型添加新的行为。Flay triat中只包含一个函数签名fly，包含了参数及参数类型，返回类型，但没有函数体，函数签名已经基本反应了该函数的所有意图，在返回值类型中甚至还可以包含错误处理相关的信息。 在triat中可以定义函数的默认实现。</p><p>Rust中没有传统面向对象语言中的继承的概念，rust中通过triat将类型和行为明确地进行了区分， 组合优于继承和面向对象接口编程的编程思想。</p><p>fly_static泛型函数，其中泛型参数声明为T， 代表任意类型， T：Flay这种语法形式使用Fly trait对泛型T进行行为上的限制，代表实现了Fly triat的类型，或者拥有fly这种行为的类型，这种限制在rust中称为trait限定 trait bound 。通过trait限定，限制了fly_static 泛型函数参数的类型范围。</p><p>fly_dyn 函数，他的参数是一个&amp;Fly类型，&amp;Fly类型是一种动态类型，代表所拥有fly这种行为的类型。</p><p>Fly_static::<Pig>(pig)在rust中叫做静态分发，对于编译器来说，这种抽象并不存在，因为在编译阶段，泛型已经被展开为具体类型的代码。</p><p>fly_dyn（&amp;Duck）函数是动态分发，会在运行时查找相应类型的方法，会带来一定的运行时开销，不过这种开销很小。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::*;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">x: <span class="built_in">i32</span>,</span><br><span class="line">  y: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Debug</span> <span class="keyword">for</span> Point &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">fmt</span></span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> Formatter) -&gt; <span class="built_in">Result</span> &#123;</span><br><span class="line">    <span class="built_in">write!</span>(f, <span class="string">"Point &#123; &#123; x: &#123;&#125;, y: &#123;&#125; &#125;&#125;"</span>, <span class="keyword">self</span>.x, <span class="keyword">self</span>.y)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> origin = Point&#123; x: <span class="number">0</span>, y: <span class="number">0</span>&#125;;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"The origin is: &#123;:p&#125;"</span>, origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Debug treat 中定义了fmt函数，所以只需要为Point实现该函数即可。</p><p>也可以使用#[derive(Debug)]属性帮助开发者自动实现Debug triat。这个属性本质上属于rust中的一种宏。</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>rust中的错误处理是通过返回Result&lt;T, E&gt;类型的方式进行的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option</span></span>&lt;T&gt; &#123;</span><br><span class="line"><span class="literal">Some</span>(T),</span><br><span class="line">  <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span></span>&lt;T, E&gt; &#123;</span><br><span class="line">  <span class="literal">Ok</span>(T),</span><br><span class="line">  <span class="literal">Err</span>(E),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> x: <span class="built_in">Result</span>&lt;<span class="built_in">i32</span>, &amp;<span class="built_in">str</span>&gt;  = <span class="literal">Ok</span>(-<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(x.is_ok()m <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">let</span> x: <span class="built_in">Result</span>&lt;<span class="built_in">i32</span>, &amp;<span class="built_in">str</span>&gt; = <span class="literal">Err</span>(<span class="string">"Some error message"</span>);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(x.is_ok(), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Is_ok() 方法来判断是否为OK(T)枚举值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; <span class="built_in">Result</span>&lt;(), std::io::Error&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> f = File::open(<span class="string">"bar.txt"</span>)?;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main函数中通过调用 File::open 方法打开一个文件，后面跟随的问号操作符？ 是一个错误处理的语法糖，他会自动在出现错误的情况下返回std::io::Error.</p><h2 id="表达式优先级"><a href="#表达式优先级" class="headerlink" title="表达式优先级"></a>表达式优先级</h2><p>在rust中一切皆表达式。</p><ul><li>路径 path</li><li>方法调用 method call</li><li>字段表达式 filed expression 从左到右</li><li>函数调用，数组索引</li><li>问号操作符 ？</li><li>一元操作符(-， *， !， &amp;，&amp;mut)</li><li>as</li><li>二元计算(*， /， %) 从左到右</li><li>二元计算(+,  -)  从左到右</li><li>位移计算(&lt;&lt;,  &gt;&gt;) 从左到右</li><li>位操作(&amp;) 从左到右</li><li>位操作(^) 从左到右</li><li>位操作(|)从左到右</li><li>比较操作（==, !=， &lt;,  &gt;,  &lt;=,  &gt;=)  需要括号</li><li>逻辑与(&amp;&amp;)从左到右</li><li>逻辑或(||)从左到右</li><li>范围(..,  ..=)  需要括号</li><li>赋值操作(=，+=， -=， *=， /=， %=， &amp;=， |=，^=,   &lt;&lt;=,   &gt;&gt;= ) 从右到左</li><li>return, break 闭包</li></ul><h2 id="注释与打印"><a href="#注释与打印" class="headerlink" title="注释与打印"></a>注释与打印</h2><p>rust文档的哲学是： 代码即文档，文档即代码。</p><ul><li>普通的注释</li><li>使用//对整行注释</li><li>使用/* …  */对区块注释。</li></ul><p>文档注释，内部指出markdown标记，也支持对文档中的示例代码进行测试，可以用rustc 工具生成html文档</p><ul><li>使用/// 注释可以生成库文档，一般用于函数或结构体的说明，置于说明对象的上方，</li><li>使用//！也可以生成文档，一般用于说明整个模块的功能，置于模块文件的头部</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// # 文档注释： Sum函数</span></span><br><span class="line"><span class="comment">/// 该函数位求和函数</span></span><br><span class="line"><span class="comment">/// # usage ：</span></span><br><span class="line"><span class="comment">/// assert_eq!(3, sum(1, 2))</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">sum</span></span>(a: <span class="built_in">i32</span>, b: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">  a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="comment">// 这是单行注释的示例</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  *这是区块注释，被包含的区块都会被注释</span></span><br><span class="line"><span class="comment">  *可以把 <span class="comment">/* 区块 */</span> 置于代码中的任何位置</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  注意上面区块中的*符号是一种注释风格，</span></span><br><span class="line"><span class="comment">  实际上并不需要</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">5</span> + <span class="comment">/*90 + */</span> <span class="number">5</span>;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(x, <span class="number">10</span>);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"2 + 3 = &#123;&#125;"</span>, sum(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Println!宏的格式：</p><ul><li>nothing 代表Display</li><li>？代表Debug</li><li>o代表八进制</li><li>x代表十六进制小写</li><li>X代表十六机制大写</li><li>p代表指针，</li><li>b代表二进制</li><li>e代表指数小写</li><li>E代表指数大写</li></ul><h1 id="The-Rust-programming-通用编程概念"><a href="#The-Rust-programming-通用编程概念" class="headerlink" title="The Rust programming  通用编程概念"></a>The Rust programming  通用编程概念</h1><p>设计的有：</p><ul><li>变量</li><li>基本类型</li><li>函数</li><li>注释</li><li>控制流等概念</li></ul><h2 id="变量与可变性"><a href="#变量与可变性" class="headerlink" title="变量与可变性"></a>变量与可变性</h2><h3 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h3><p>Rust中变量默认是不可变的，rust语言提供这一概念是为了能够让你安全且方便地写出复杂、甚至并行的代码。</p><p>当一个变量是不可变的时候，一旦绑定到某个值上面。这个值就再也无法被改变。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// ^ first assigment to 'x'</span></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"The value of x is: &#123;&#125;"</span>, x);</span><br><span class="line">  x = <span class="number">6</span>;</span><br><span class="line">  <span class="comment">// ^ cannot assign twice to immutable variable</span></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"The value of x is: &#123;&#125;"</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// e0384: cannot assign twice to immutable variable 'x'</span></span><br></pre></td></tr></table></figure><p>Rust 的编译器能够保证那些声明为不可变的值一定不会发生改变，这意味着你无须在阅读和编写diamanté时追踪一个变量如何变化的，从而使代码逻辑更加易于理解和推导。</p><h3 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h3><p>变量默认是不可变的，也可以通过声明变量名称前添加mut关键字来使其可变。mut会向阅读代码的人暗示其他代码可能会改变这个变量的值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="number">5</span>;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"The value of x is : &#123;&#125;"</span>, x);</span><br><span class="line">  x = <span class="number">6</span>;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"The value of x is : &#123;&#125;"</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用：</p><p>除了避免出现bug，设计一个变量的可变性还需要考虑许多因素，当你在使用某些重型数据结构的时候，适当地使用可变性去修改一个实例，可能比赋值和重新返回一个新分配的实例要更有效；而当数据结构较为轻量的时候，采用更偏向函数式的风格，通过创建新变量来进行赋值，可能会使代码更加易于理解。</p><h2 id="变量与常量之间的不同"><a href="#变量与常量之间的不同" class="headerlink" title="变量与常量之间的不同"></a>变量与常量之间的不同</h2><p>常量 constant ，像不可变变量一样，绑定到常量上的值无法被其他代码修改，但常量和变量之间还是存在一些细微的差别。</p><ul><li>不能用mut关键字来修饰一个常量，常量不仅是默认不可变的，他还总是不可变的。</li><li>使用const关键字而不是let关键字来声明一个常量。</li><li>常量可以被声明在任何作用域中，甚至包括全局作用域，这在一个值需要被不同部分的代码共同引用时十分有用。</li><li>只能将常量绑定到一个常量表达式上，而无法将一个函数的返回值，或其他需要在运行时计算的值绑定到常量上。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MAX_POINTS : <span class="built_in">u32</span> = <span class="number">100_000</span>;</span><br></pre></td></tr></table></figure><p>常量在整个程序运行的过程中都在自己声明的作用域内有效，这使得常量可以被用在程序的不同代码之间共享值。</p><p>将整个程序中硬编码的值声明为常量并给予其有意义的名字，可以帮助后来的维护者理解这些值的意义。而使用同一常量来索引相同的硬编码值也能为将来的修改提供方便。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Rust-编程之道-第二章-语言精要&quot;&gt;&lt;a href=&quot;#Rust-编程之道-第二章-语言精要&quot; class=&quot;headerlink&quot; title=&quot;Rust 编程之道 第二章 语言精要&quot;&gt;&lt;/a&gt;Rust 编程之道 第二章 语言精要&lt;/h1&gt;&lt;p&gt;​     
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
