<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  <title>第二章 语言精要 | Davirain</title>
  <meta name="author" content="davirain">
  
  <meta name="description" content="第二章 语言精要​                                                                                                                                        好读书，不">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="第二章 语言精要"/>
  <meta property="og:site_name" content="Davirain"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Davirain" type="application/atom+xml">
  
<link rel="stylesheet" href="/css/style.css">

  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Davirain</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article id="post-第二章 语言精要" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2020-06-26T04:11:19.830Z"><a href="/2020/06/26/第二章 语言精要/">2020-06-26</a></time>
      
      
  
    <h1 class="p-name title" itemprop="headline name">第二章 语言精要</h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h1 id="第二章-语言精要"><a href="#第二章-语言精要" class="headerlink" title="第二章 语言精要"></a>第二章 语言精要</h1><p>​                                                                                                                                        好读书，不求甚解；每有会意，便欣然忘食。</p>
<p><strong>动手，动手，动手！！！</strong></p>
<h2 id="语句与表达式"><a href="#语句与表达式" class="headerlink" title="语句与表达式"></a>语句与表达式</h2><p>Rust 中语法可以分成两大类：语句 statement 和表达式 expression。语句是指要执行的一些操作和产生副作用的表达式。</p>
<p>表达式主要用于计算求值。</p>
<p>语句又分为两种：声明语句 Declaration statment 和表达式语句 Expression statement</p>
<ul>
<li>​    声明语句，用于声明各种语言项，包括声明变量、静态变量、常量、结构体、函数等，以及通过extern 和use关键字引入包和模块。</li>
<li>表达式语句，特指以分号结尾的表达式。此类表达式求值结果将会被舍弃，并总是返回单元类型（）。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//extern crate std; </span></span><br><span class="line"><span class="comment">// use std::prelude::v1::*;</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">answer</span></span>() -&gt; () &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">40</span>;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(sum(a,b), <span class="number">42</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sum</span></span>(a: <span class="built_in">i32</span>, b: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span>&#123;</span><br><span class="line">    a + b</span><br><span class="line">  &#125;</span><br><span class="line">  answer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        Extern cate std; 和 use std::prelude::v1::*; 是声明语句，他们并不需要求值，只是用来引入标准库包以及prelude模块。</p>
<p>​        rust 会为每个crate都自动引入标准库模块，除非使用#[no_std]属性明确指定了不需要标准库。</p>
<p>​        使用fn关键子定义了函数，函数answer没有输入参数，并且返回类型为<strong>单元类型（）</strong>。单元类型拥有唯一的值，就是它本身，为了描述方便，将该值称为<strong>单元值</strong>。单元类型的概念来自Ocmal，他表示“没有什么特殊的值”。所以，这里将单元类型作为函数返回值，就是表示该函数无返回值。通常没有返回值的函数默认是不需要在函数签名中指定返回类型的。</p>
<p>​        使用了let声明变量assert_eq! 则是宏语句，踏实rust提供的断言，允许判断给定的两个表达式求值结果是否相同。像这种名字以叹号结尾，并且可以像函数一样被调用的语句，在rust中叫做<strong>宏</strong>。</p>
<p>​        rust编译器在解析代码的时候，如果碰到分号，就会继续往后面执行；如果碰到语句，则执行语句；如果碰到表达式，则会对表达式求值，如果分号后面什么都没有，就会补上单元值（）。</p>
<p>​        当遇到函数的时候，会将函数体的花括号识别为块表达式 Block expression。块表达式是由一对花括号和系列表达式组成的。他总是返回块中最后一个表达式的值。</p>
<p>​        从这个角度看，可以讲rust看作一切皆表达式。由于当分号后面什么都没有时自动补单元值（）的特点。我们可以将rust中的语句看作计算结果均为（）的特殊表达式。而对于普通表达式来说，则会得到正常的求值结果。</p>
<h2 id="变量与绑定"><a href="#变量与绑定" class="headerlink" title="变量与绑定"></a>变量与绑定</h2><p>通过let关键字来创建变量，这是rust函数从函数式语言中借鉴的语法形式。let创建的变量一般称为绑定 binding。它表明了标识符 identifier 和值value 之间建立的一种关联关系。</p>
<h3 id="位置表达式和值表达式"><a href="#位置表达式和值表达式" class="headerlink" title="位置表达式和值表达式"></a>位置表达式和值表达式</h3><p>rust中的表达式一般分为位置表达式 place expression 和值表达式 value expression。在其他语言中，一般叫做左值 lvalue和右值rvalue。</p>
<p>位置表达式就是表示内存位置的表达式。分类有：</p>
<ul>
<li>本地变量</li>
<li>静态变量</li>
<li>解引用 （*epr）</li>
<li>数组索引（expr[expr])</li>
<li>字段引用（exp.field)</li>
<li>位置表达式组合</li>
</ul>
<p>通过位置表达式可以对某个数据单元的内存进行读写。主要进行写操作，这也是位置表达式可以被赋值的原因。</p>
<p>值表达式一般只引用了某个存储单元地址中的数据。它相当于数据值，只能进行读操作。</p>
<p>从语义角度来说，位置表达式代表了持久性数据，值表达式代表了临时数据。位置表达式一般有持久的状态，值表达式要么是自面量，要么是表达式求值过程中创建的临时值。</p>
<p>表达式的求值过程在不同的上下文中会有不同的结果。求值上下文也分为位置上下文 place context 和值上下文 value context。</p>
<p>下面几种表达式属于位置上下文：</p>
<ul>
<li>赋值或者复合赋值语句左侧的操作数。</li>
<li>一元引用表达式的独立操作数。</li>
<li>包含隐式借用（引用）的操作数。</li>
<li>match 判别式或者let绑定右侧在使用ref模式匹配的时候也是位置上下文。</li>
</ul>
<p>除了上述几种情况，其余表达式都属于值上下文。值表达式不能出现在位置上下文中。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">temp</span></span>() -&gt; <span class="built_in">i32</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> x = &amp;temp();</span><br><span class="line">  temp() = *x; <span class="comment">//e0070: invalid left-hand size expression</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在main函数中，使用temp函数调用放到赋值语句左边的位置上下文中，此时编译器会报错。因为temp函数调用是一个无效的位置表达式，它是值表达式。</p>
<h3 id="不可变绑定与可变绑定"><a href="#不可变绑定与可变绑定" class="headerlink" title="不可变绑定与可变绑定"></a>不可变绑定与可变绑定</h3><p>使用let关键字声明的位置表达式默认不可变，为不可变绑定。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// a = 2; //immytable and error</span></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> b = <span class="number">2</span>;</span><br><span class="line">  b = <span class="number">3</span>; <span class="comment">// mutable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量a默认是不可变绑定，对其重新复制后编译器会报错。通过mut关键字，可以声明可变位置表达式，即可变绑定。可变绑定可以正常修改和赋值。</p>
<p>从语义上来说，let声明的不可变绑定只能对相应的存储单元进行读取，而let mut 声明的可变绑定则是可以对相应的存储单元进行写入。</p>
<h3 id="所有权与引用"><a href="#所有权与引用" class="headerlink" title="所有权与引用"></a>所有权与引用</h3><p>当位置表达式出现在值上下文中，该位置表达式将会把内存地址转移到另一个位置表达式，这是所有权的转移。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> place1 = <span class="string">"hello"</span>;</span><br><span class="line">  <span class="keyword">let</span> place2 = <span class="string">"hello"</span>.to_string();</span><br><span class="line">  <span class="keyword">let</span> other = place1;<span class="comment">//Copy</span></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, place1); </span><br><span class="line">  <span class="keyword">let</span> other = place2;<span class="comment">// Move</span></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, place2); <span class="comment">//place2 value used here after move</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>place1是绑定的是一个字符串字面量，对于字符串字面量来说，和基本类型都一样都有Copy trait，在赋值操作时执行的是Copy操作，不回所有权的移动，现在出现在赋值操作符右侧，这里let other = place1; 会执行place1的拷贝操作，在执行之后，打印place1仍然是可以的。</p>
<p>而place2是String类型，没有Copy triat，这里赋值后，会发生所有权的移动。接着打印place2会出现错误，place2 value used here after move</p>
<p><strong>在语义上，每个变量实际上都拥有该存储单元的所有权，这种转移所有权地址的行为就是所有权ownership的转移，在rust中称为移动 move 语义。那种不转移的情况。实际是上是一种复制copy语义。Rust没有GC， 所以完全依靠所有权来管理内存管理。</strong></p>
<p>在日常开发中，有时并不需要转移所有权。Rust提供<strong>引用操作符&amp;</strong>， 可以直接获取表达式的存储单元地址，即内存地址。可以通过该内存位置对存储进行读取。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">  <span class="keyword">let</span> b = &amp;a;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;:p&#125;"</span>, b); <span class="comment">// 0x7fffcbc067704</span></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> c = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">  <span class="keyword">let</span> d = &amp;<span class="keyword">mut</span> c;</span><br><span class="line">  d.push(<span class="number">4</span>);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, d);<span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line">  <span class="keyword">let</span> e = &amp;<span class="number">42</span>;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="number">42</span>, *e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面定义了固定长度数组a，并使用引用操作符&amp;取得a的内存地址，赋值给b。这种方式不会引起所有权的转移，因为使用引用操作符已经将赋值表达式右侧变成了位置上下文，他只是共享内存地址。通过println! 宏指定{:p}格式，可以打印b的指针地址。也就是内存地址。</p>
<p>通过let mut 声明了动态长度数组c，然后通过&amp;mut 获取c的可变引用，赋值给d。</p>
<p><strong>注意，要获取可变引用，必须先声明可变绑定。</strong></p>
<p>对于字面量42来说，其本省属于值表达式。通过引用操作符，相当于值表达式在位置上下文中进行求值，所以编译器会为&amp;42创建一个临时值。</p>
<p>最后，通过解引用操作符*将引用e中的值取出来，以供assert_eq!宏使用。</p>
<p>从语义上来说，不管&amp;a还是&amp;mut c；都相当于对a和c所有权的借用，因为a和c还依旧保留他们的所有权，所以引用也被称为借用。</p>
<h2 id="函数与闭包"><a href="#函数与闭包" class="headerlink" title="函数与闭包"></a>函数与闭包</h2><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p>main函数，它代表程序的入口。对于二进制可执行文件来说，main函数必不可少。对于库函数来说，mian函数就没有必要。</p>
<p>函数是通过关键字fn定义的。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">fizz_buzz</span></span>(num: <span class="built_in">i32</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> num % <span class="number">15</span> == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"fizzbuzz"</span>.to_string();</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> num % <span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"fizz"</span>.to_string();</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> num % <span class="number">5</span> == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"buzz"</span>.to_stirng();</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num.to_string();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(fizz_buzz(<span class="number">15</span>), <span class="string">"fizzbuzz"</span>.to_string());</span><br><span class="line">  <span class="built_in">assert_eq!</span>(fizz_buzz(<span class="number">3</span>), <span class="string">"fizz"</span>.to_string());</span><br><span class="line">  <span class="built_in">assert_eq!</span>(fizz_buzz(<span class="number">5</span>), <span class="string">"buzz"</span>.to_string());</span><br><span class="line">  <span class="built_in">assert_eq!</span>(fizz_buzz(<span class="number">13</span>), <span class="string">"13"</span>.to_string());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用fn关键字定义了fizz_buzz函数，其函数签名pub fn fizz_buzz(num: i32) -&gt; String 清晰地反映了函数的类型约定：传入i32类型，返回Srtring类型。<strong>Rust编译器会严格遵守此类型的契约，如果传入或返回的不是约定好的类型，则会编译时出错。</strong> </p>
<p>return表达式用于退出一个函数，并返回一个值。但是如果return后买呢没有值，就会默认返回单元值。</p>
<p>使用了to_string 方法，他将表达式的求值结果转换成Siting类型。</p>
<h3 id="作用域与生命周期"><a href="#作用域与生命周期" class="headerlink" title="作用域与生命周期"></a>作用域与生命周期</h3><p>Rust语言的作用域是静态作用域，即词法作用域 Lexical scope。由一对花括号来开辟作用域，其作用域在词法分析阶段就已经确定了，不回动态该改变。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> v = <span class="string">"hello world!"</span>;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(v, <span class="string">"hello world!"</span>);</span><br><span class="line">  <span class="keyword">let</span> v = <span class="string">"hello Rsut!"</span>;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(v, <span class="string">"hello Rsut!"</span>);</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="string">"hello Wolrd!"</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v, <span class="string">"hello World!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(v, <span class="string">"hello Rust!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先定义了变量绑定v，赋值为hello world！，然后通过断言验证其值。再次通过let声明变量绑定v，赋值为hello Rust！这种定义同名变量的做法叫做<strong>变量遮蔽 variable shadow</strong>。但是最终的变量v的值是由第二个变量定义所决定的。</p>
<p>在词法作用域内部使用花括号开辟新的词法作用域后，两个作用域是相互独立的。在不同的词法作用域内声明的变量绑定，拥有不同的生命周期 lifetime。 <strong>变量绑定的生命周期总是遵循这样的规律：从使用let声明创建变量绑定开始，到超出词法作用域的范围时结束。</strong></p>
<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>在rust 中，<strong>函数为一等公民</strong>。这意味，函数自身既可以作为函数的参数和返回值使用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">math</span></span>(op: <span class="function"><span class="keyword">fn</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span>, a: <span class="built_in">i32</span>, b: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">  op(a, b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">sum</span></span>(a: <span class="built_in">i32</span>, b: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">  a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">product</span></span>(a: <span class="built_in">i32</span>, b: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">  a * b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(math(sum, a, b), <span class="number">5</span>);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(math(product, a, b), <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义了函数math, 其函数签名的第一个参数为fn(i32, i32) -&gt; i32 类型， 这在rust中时函数指针 fn pointer类型。</p>
<p>这里直接使用函数的名字作为函数指针。</p>
<p>函数也可以作为返回值使用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">is_true</span></span>() -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">  <span class="literal">true</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">true_maker</span></span>() -&gt; <span class="function"><span class="keyword">fn</span></span>() -&gt; <span class="built_in">bool</span> &#123; </span><br><span class="line">  is_true</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(true_maker()(), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义了函数true_maker,返回fn() -&gt; bool 类型，其函数体内直接将is_true函数指针返回。注意此处也使用了函数名字作为函数指针，如果加上括号，就会调用该函数。</p>
<p>在main函数的断言中，true_maker()()调用相当于(true_maker() ) ()。 首先调用true_maker(), 会返回is_true函数指针；然后再调用is_true()函数，最终得到true。</p>
<h3 id="CTEE机制"><a href="#CTEE机制" class="headerlink" title="CTEE机制"></a>CTEE机制</h3><p>rust编译器可以像C++，拥有编译时函数执行 compile - time function execution , CTTE的能力。 </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![feature(const_fn)]</span></span><br><span class="line"><span class="keyword">const</span> <span class="function"><span class="keyword">fn</span> <span class="title">init_len</span></span>() -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [<span class="number">0</span>; init_len()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用了const fn 来定义函数init_len, 该函数返回一个固定值5. 并且在main函数中，通过[0; N]这种形式来初始化初始值为0， 长度为N的数组，其中N时由调用函数init_len来求得的。</p>
<p>Rust中固定的数组必须在编译期就知道长度，否则会编译出错。所以函数init_len必须在编译器求值。这就是CTTE的能力。</p>
<p>使用const fn 定义的函数，必须可以确定值，不能存在歧义。与定义fn函数的区别在于， const fn 可以强制编译器在编译期执行函数。其中关键字const一般用于定义全局常量。</p>
<p>除了const fn，官方还在实现const generics特性。 支持const generics 特性，将可以实现类似impel &lt; T, const N: usize&gt; Foo for [T:N] {… } 的代码。可以为所有长度的数组实现trait Foo.</p>
<p>Rust中的CTTE是由miri来执行的。miri是一个MIR解释器，目前已经被集成到Rust编译器rustc中。rust 编译器目前可以支持的常量表达式有：字面量、元组、数组、字段结构体、枚举、只包含单行代码的块表达式、范围等。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包也叫做匿名函数。闭包的特点：</p>
<ul>
<li>可以像函数一种被调用。</li>
<li>可以捕获上下文环境中的自由变量。</li>
<li>可以自动推断输入和返回的类型。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> out = <span class="number">42</span>;</span><br><span class="line">  <span class="comment">// fn add(i:i32, j: i32) -&gt; i32 &#123; i + j + out &#125;</span></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(i: <span class="built_in">i32</span>, j: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123; i + j&#125;</span><br><span class="line">  <span class="keyword">let</span> closure_annotated = |i: <span class="built_in">i32</span>, j:<span class="built_in">i32</span>| -&gt; <span class="built_in">i32</span> &#123; i + j + out &#125;;</span><br><span class="line">  <span class="keyword">let</span> closure_inferred = |i, j| i + j + out;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="number">3</span>, add(i, j));</span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="number">45</span>, closure_annotated(i,j));</span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="number">45</span>, closure_inferrend(i,j));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>闭包函数有一个重要的区别，就是闭包可以捕获外部变量，而函数不可以。 </p>
<p>闭包也可以作为函数参数和返回值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">closure_math</span></span>&lt;F: <span class="built_in">Fn</span>() -&gt; <span class="built_in">i32</span> &gt;(op: F) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">  op()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(clousre_math(|| a + b), <span class="number">5</span>);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(clousre_math(|| a * b), <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义了函数closure_math,其参数是一个泛型F， 并且泛型受Fn() -&gt; i32 trait的限定，代表函数只允许实现Fn()-&gt;i32 trait的类型作为参数。</p>
<p><strong>Rust中闭包实际上就是一个匿名结构体和trait来组合实现的。</strong></p>
<p>闭包也可以作为返回值，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">two_times_impl</span></span>() -&gt; <span class="keyword">impl</span> <span class="built_in">Fn</span>(<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">move</span> |j| j * i</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> result = two_times_impl();</span><br><span class="line">  <span class="built_in">assert_eq!</span>(result(<span class="number">2</span>), <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在函数定义时并不知道具体的返回类型，但是在函数调用时，编译器会推断出来。这个过程也是零成本抽象的，一切都发生在编译器。</p>
<p><strong>在函数two_times_imple中最后返回闭包时使用了move关键字，这是因为在一般情况下，闭包默认会岸引用捕获变量。如果将此闭包返回，则引用也会跟着返回变量i的引用，也将成为悬垂指针。使用move关键字，将捕获变量i的所有权转移到闭包中，就不会按引用进行捕获变量，这样闭包才可以安全地返回。</strong></p>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>流程控制表达式</p>
<h3 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h3><p>表达式一定会有值，所以if表达式的分支必须返回一个类型的值才可以。if表达式的求值规则和块表达式一致。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">13</span>;</span><br><span class="line">  <span class="keyword">let</span> big_n = <span class="keyword">if</span> ( n &lt; <span class="number">10</span> &amp;&amp; n &gt; -<span class="number">10</span> )&#123;</span><br><span class="line">    <span class="number">10</span> * n</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    n / <span class="number">2</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(big_n, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环表达式"><a href="#循环表达式" class="headerlink" title="循环表达式"></a>循环表达式</h3><p>rust中包括三种循环表达式： while， loop和for … in 表达式。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">for</span> n <span class="keyword">in</span> <span class="number">1</span>..<span class="number">101</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">15</span> == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="built_in">println!</span>(<span class="string">"fizzbuzz"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> n % <span class="number">3</span> == <span class="number">0</span>&#123;</span><br><span class="line">      <span class="built_in">println!</span>(<span class="string">"fizz"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> n % <span class="number">5</span> == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="built_in">println!</span>(<span class="string">"buzz"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>For .. in 表达式本质上是一个迭代器，其中1..101 是一个range类型，它是一个迭代器。for的每一次循环都从迭代器中取值，当迭代器中没有值的时候，for循环结束。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">while_true</span></span>(x: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> <span class="literal">true</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> y = while_true(<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(y, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中while循环条件使用了硬编码true，目的是实现无限循环。这种看似非常正确的代码会引起rust编译器报错。</p>
<p>错误提示称while true 循环块返回的是单元值，而函数while_true返回值是i32， 所以不匹配。但是在while true 循环中使用了return关键字，应该返回i32类型才行。为什么会报错呢？</p>
<p>这是因为rust编译器在对while循环做流分析 Flow sensitive 的时候，不会检查循环条件，编译器会认为while循环条件可真可假，所以循环体里的表达式也会被忽略，此时编译器只知道while true 循环返回的是单元值，而函数返回的是i32。其他情况一概不知。这一切都是因为CTEE功能的限制，while条件表达式无法作为编译器常量来使用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">while_true</span></span>(x: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> <span class="literal">true</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在while_true函数的最后一行加了x变量，这是为了让编译器以为返回的类型是i32类型，但实际上，程序在运行以后，将永远在while true 循环汇中执行。</p>
<h3 id="match-表达式与模式匹配"><a href="#match-表达式与模式匹配" class="headerlink" title="match 表达式与模式匹配"></a>match 表达式与模式匹配</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> number = <span class="number">42</span>;</span><br><span class="line">  <span class="keyword">match</span> number &#123;</span><br><span class="line">    <span class="number">0</span> =&gt; <span class="built_in">println!</span>(<span class="string">"Origin"</span>),</span><br><span class="line">    <span class="number">1</span>...<span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">"All"</span>),</span><br><span class="line">    |<span class="number">5</span>|<span class="number">7</span>|<span class="number">13</span> =&gt; <span class="built_in">println!</span>(<span class="string">"Bad luck"</span>),</span><br><span class="line">    n @ <span class="number">42</span> =&gt; <span class="built_in">println!</span>(<span class="string">"Answer is &#123;&#125;"</span>, n),</span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">"Common"</span>),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在rust语言中，match分支使用了模式匹配 pattern matching 技术。模式匹配在数据结构字符串中经常出现，比如在某个字符串中找出与该字符串相同的所有子串。在编程语言中，模式匹配用于判断类型或者值是否存在可以匹配的模式。模式匹配在很多函数式语言中已经被广泛应用。</p>
<p>在rust语言中，match分支左边就是模式，右边就是执行代码。模式匹配同时也是一个表达式，与if表达式类似，所有分支必须返回一个类型。但是左侧的模式可以是不同的。</p>
<p>使用操作符@可以将模式中的值绑定给一个变量。供分支右侧的代码使用，这类匹配叫做绑定模式 Bindingmode。match表达式必须穷尽每一种可能，所以一般情况下会使用通配符_来处理剩余的情况。</p>
<h3 id="if-let-和-while-let表达式"><a href="#if-let-和-while-let表达式" class="headerlink" title="if let 和 while let表达式"></a>if let 和 while let表达式</h3><p>rust还提供了if let 和while let表达式，分别来在某些场合替代match表达式。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> boolean = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> binary = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">true</span> = boolean &#123;</span><br><span class="line">    binary = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(binary, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>if let 左侧为模式，右侧为要匹配的值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">  <span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> v.pop() &#123;</span><br><span class="line">      <span class="literal">Some</span>(x) =&gt; <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x),</span><br><span class="line">      <span class="literal">None</span> =&gt; <span class="keyword">break</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用v的pop方法返回Option类型，所以用match匹配两种情况，Some(x)和None， Rust中引入Option类型是为了防止空指针的出现。Some(x)用于匹配数组中的元素，而None用于匹配数组被取空的情况。当数组为空时，就从循环中跳出。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">  <span class="keyword">while</span> <span class="keyword">let</span> <span class="literal">Some</span>(x) = v.pop() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">let</span> y: <span class="built_in">bool</span> = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">5</span>; <span class="comment">//变量遮蔽</span></span><br><span class="line">  <span class="keyword">if</span> x &gt; <span class="number">1</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"x is bigger than 1"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(x <span class="keyword">as</span> <span class="built_in">i32</span>, <span class="number">1</span>); <span class="comment">// 5 ！= 1</span></span><br><span class="line">  <span class="built_in">assert_eq!</span>(y <span class="keyword">as</span> <span class="built_in">i32</span>, <span class="number">0</span>); <span class="comment">// 0 == 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于第一个x的绑定，rust可以自动推断器类型为bool。</p>
<p>任意一个比较操作都会产生bool类型。</p>
<p>可以通过as操作符将bool类型转换成数组0或者1， 但注意的是，Rust并不知耻将数字转换成bool类型。</p>
<h3 id="基本数据类型-1"><a href="#基本数据类型-1" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>rust提供的基本数据类型大致分为：固定大小的类型、动态大小的类型和浮点数。</p>
<ul>
<li><p>固定大小的类型包括无符号整数 unsigned integer 和符号整数 signed integer。</p>
<ul>
<li>其中无符号整数包括：<ul>
<li>u8，  占用1个字符。u8类型通常在rust中表示字节序列。在文件io或者网络IO中读取数据流时需要使用u8。</li>
<li>u16，占用2个字节</li>
<li>u32，占用4个字节</li>
<li>U64， 占用8个字节</li>
<li>u128， 占用16个字节</li>
</ul>
</li>
<li>符号整数：<ul>
<li>i8，占用1个字节</li>
<li>I6， 占用2个字节</li>
<li>I32， 占用4个字节</li>
<li>i64，占用8个字节</li>
<li>I128，占用16个字节</li>
</ul>
</li>
<li>动态大小类型：<ul>
<li>usize， 占用4个或者8个字节，取决于机器的字长。</li>
<li>isize， 占用4个或者8个字节，取决于机器的字长。</li>
</ul>
</li>
<li>浮点数类型：<ul>
<li>F32， 单精度32位浮点数， 至少6位有效数字。</li>
<li>F64， 单精度64位浮点数，至少15位有效数字。</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> num = <span class="number">42u32</span>;</span><br><span class="line">  <span class="keyword">let</span> num : <span class="built_in">u32</span> = <span class="number">42</span>;</span><br><span class="line">  <span class="keyword">let</span> num = <span class="number">0x2A</span>; </span><br><span class="line">  <span class="keyword">let</span> num = <span class="number">0o106</span>;</span><br><span class="line">  <span class="keyword">let</span> num = <span class="number">0b1101_1011</span>;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="string">b'*'</span>, <span class="number">42u8</span>);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="string">b'\''</span>, <span class="number">39u8</span>);</span><br><span class="line">  <span class="keyword">let</span> num = <span class="number">3.1415926f64</span>;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(-<span class="number">3.14</span>, -<span class="number">3.14f64</span>);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="number">2</span>., <span class="number">2.0f64</span>);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="number">2e4</span>, <span class="number">20000f64</span>);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, std::<span class="built_in">f32</span>::INFINITY);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, std::<span class="built_in">f32</span>::NEG_INFINITY);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, std::<span class="built_in">f32</span>::NAN);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, stf::<span class="built_in">f32</span>::MIN);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, std::<span class="built_in">f32</span>::MAX);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Rust中可以写字节字面量， 比如以b开头的字符b’*’ ,它实际等价于42u8</p>
</li>
</ul>
<h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><p>在rust中，使用单引号来定义字符类型。字符类型代表的是一个unicode标量，每个字符占4个字节。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> x= <span class="string">'r'</span>;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="string">'U'</span>;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="string">'\''</span>);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="string">'\\'</span>);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="string">'\n'</span>);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="string">'\r'</span>);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="string">'\t'</span>);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="string">'\x2A'</span>, <span class="string">'*'</span>);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="string">'\x25'</span>, <span class="string">'%'</span>);</span><br><span class="line">  <span class="built_in">assert_eq!</span>('\u&#123;CA0&#125;', <span class="string">'8'</span>);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="string">'%'</span> <span class="keyword">as</span> <span class="built_in">i8</span>, <span class="number">37</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><p>数组array时rust内建的原始集合类型，数组的特点：</p>
<ul>
<li>数组大小固定。</li>
<li>元素均为同类型。</li>
<li>默认不可变。</li>
</ul>
<p>数组的类型签名位[T;N].T是一个泛型标记。代表数组中元素的某个具体类型。N代表数组的长度，是一个编译时常量，必须在编译时确定其值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> arr: [<span class="built_in">i32</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> mut_arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="number">1</span>, mut_arr[<span class="number">0</span>]);</span><br><span class="line">  mut_arr[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="number">3</span>, mut_arr[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">let</span> init_arr = [<span class="number">0</span>; <span class="number">10</span>];</span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="number">0</span>, init_arr[<span class="number">5</span>]);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="number">10</span>, init_arr.len());</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, arr[<span class="number">5</span>]);<span class="comment">// Error: index out of bounds</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于原始固定长度数组，只有实现Copy trait的类型才能作为其元素。也就是说，只有可以在栈上存放的元素才可以存放在该类型的数组中。Rust还将支持VLA variable length array数组， 即可变长数组。对于可变长数组，将会基于可以在栈上动态分配内存的函数来实现。</p>
<h3 id="范围类型"><a href="#范围类型" class="headerlink" title="范围类型"></a>范围类型</h3><p>Rust内置来范围Range类型，包活左闭右开和全闭两种区间。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="built_in">assert_eq!</span>((<span class="number">1</span>..<span class="number">5</span>), std::ops::Range(start: <span class="number">1</span>, end: <span class="number">5</span>));</span><br><span class="line">  <span class="built_in">assert_eq!</span>((<span class="number">1</span>..=<span class="number">5</span>), std::ops::RangeInclusive::new(<span class="number">1</span>, <span class="number">5</span>));</span><br><span class="line"> 	<span class="built_in">assert_eq!</span>(<span class="number">3</span>+<span class="number">4</span>+<span class="number">5</span>, (<span class="number">3</span>..<span class="number">6</span>).sum());</span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="number">3</span>+<span class="number">4</span>+<span class="number">5</span>+<span class="number">6</span>, (<span class="number">3</span>..=<span class="number">6</span>).sum());</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">5</span>)&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> (<span class="number">1</span>..=<span class="number">5</span>)&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个范围都是一个迭代器， 可以直接使用for循环打印。</p>
<h3 id="切片类型"><a href="#切片类型" class="headerlink" title="切片类型"></a>切片类型</h3><p>切片slice类型是对一个数组（包括固定大小数组和动态数组）的引用片段，有利于安全有效地访问数组的一部分，而不需要拷贝。</p>
<p>因为理论上，切片引用的是已经存在的变量。在底层，切片代表一个指向数组起始位置的指针和数组长度。用[T]类型表示连续序列，那么切片类型就是&amp;[T]和&amp;mut[T].</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> arr : [<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">  <span class="built_in">assert_eq!</span>(&amp;arr, &amp;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(&amp;arr[..], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(&amp;arr.len(), &amp;<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(&amp;arr.is_empty(), &amp;<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">let</span> arr = &amp;<span class="keyword">mut</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">  arr[<span class="number">1</span>] = <span class="number">7</span>;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(arr, &amp;[<span class="number">1</span>, <span class="number">7</span>, <span class="number">3</span>]);</span><br><span class="line">  <span class="keyword">let</span> vec = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">  <span class="built_in">assert_eq!</span>(&amp;vec[..], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过引用操作符&amp;对数组进行引用，就产生了一个切片&amp;arr，也可以结合范围对数组进行切割，比如&amp;arr[1..], 表示获取arr数组中在索引位置1之后的所有元素。</p>
<p>切片提供了两个const fn 方法，len和is_empty,分别用来得到切片的长度和判断切片是否为空。</p>
<p>通过&amp;mut可以定义可变切片，这个样可以直接通过索引来修改相应位置的值。</p>
<p>对于使用vec!宏定义的数组，也可以通过引用操作符来得到一个切片。</p>
<h3 id="str字符串类型"><a href="#str字符串类型" class="headerlink" title="str字符串类型"></a>str字符串类型</h3><p>Rust提供了原始的字符串类型str，也叫做字符串切片。它通常以不可变借用的形式存在，即&amp;str。出于安全的考虑，Rust将字符串分成两种类型。一种是固定长度字符串，不可随便更改其长度类型，就是str字符串；另一种是可增长字符串，可以随意改变其长度，就是String字符串。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> truth: &amp;<span class="symbol">'static</span> <span class="built_in">str</span> = <span class="string">"Rust is a system programming language"</span>;</span><br><span class="line">  <span class="keyword">let</span> ptr = truth.as_ptr();</span><br><span class="line">  <span class="keyword">let</span> len = truth.len();</span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="number">28</span>, len);</span><br><span class="line">  <span class="keyword">let</span> s = <span class="keyword">unsafe</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> slice = std::slice::from_raw_parts(ptr, len);</span><br><span class="line">    std::<span class="built_in">str</span>::from_utf8(slice);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(s, <span class="literal">Ok</span>(truth));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字符串字面量也属于str类型，只不过它是静态生命周期字符床&amp;’static str.所谓静态生命周期，可以理解为该类型字符串和程序代码一样是持久有效的。</p>
<p>str字符串类型由两部分组成：指向字符串序列的指针和记录长度的值。可以通过str模块提供的as_ptr和len方法分别求得指针和长度。</p>
<p>Rust中字符串本质上是一段有效的UTF8字节序列。所以可以将一段字节序列转换成str字符串。</p>
<p>通过std::slice::from_raw_parts函数，传入指针和长度，可以将相应的字节序列转换为切片类型&amp;[u8].再使用std::str::from_utf8函数将得到的切片转换成str字符串。因为整个过程中并没有验证字节序列是否为合法的utf8字符串，所以需要放到unsafe块中执行整个转换过程。</p>
<h3 id="原生指针"><a href="#原生指针" class="headerlink" title="原生指针"></a>原生指针</h3><p>将表示内存地址的类型成为指针。Rust提供了多种类型的指针，包括引用 Reference、原生指针 Raw pointer、函数指针</p>
<p>和智能指针 smart Pointer</p>
<p>引用，本质上是一种非空指针。Rust可以划分为Safe Rust 和Unsafe Rust。引用主要用于Safe Rust中，在Safe Rsut中，编译器会对引用进行借用检查，以保证内存安全和类型安全。</p>
<p>原生类型主要用于Unsafe Rust中。直接使用原生指针是不安全的，比如原生指针可能指向一个null，或者一个已经释放的内存区域，因为使用原生指针的地方不再Safe Rust的可控范围内，所以需要程序员自己保证安全。Rust支持两种原生指针：不可变原生指针 * const T和可变原生指针 * mut T。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">let</span> ptr _x = &amp;<span class="keyword">mut</span> x <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">i32</span>;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="built_in">Box</span>::new(<span class="number">20</span>);</span><br><span class="line">  <span class="keyword">let</span> ptr_y = &amp;*y <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">i32</span>;</span><br><span class="line">  <span class="keyword">unsafe</span> &#123;</span><br><span class="line">    *ptr_x += *ptr_y;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(x, <span class="number">30</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过as操作符将&amp;mut x可变引用转换成* mut i32可变原生指针 ptr-x</p>
<p>使用Box::new(20) 代表在堆内存上存储数字20，然后通过一系列操作转成不可变原生指针ptr_y</p>
<p>注意操作原生指针要使用unsafe块。</p>
<h3 id="never类型"><a href="#never类型" class="headerlink" title="never类型"></a>never类型</h3>
      
    </div>
    <footer>
      
        
        
        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">Comments</h1>

  
      <div id="fb-root"></div>
<script>
  (function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s); js.id = id;
    js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=123456789012345";
    fjs.parentNode.insertBefore(js, fjs);
  }(document, 'script', 'facebook-jssdk'));
</script>

<div class="fb-comments" data-href="https://davirain.github.io/2020/06/26/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%A6%81/index.html" data-num-posts="5" data-width="840" data-colorscheme="light"></div>
      
  
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="as_sitesearch" value="davirain.github.io">
  </form>
</div>


  

  
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2020 davirain
  
</div>
<div class="clearfix"></div></footer>
  
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/jquery.imagesloaded.min.js"></script>


<script src="/js/gallery.js"></script>






<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script src="/fancybox/jquery.fancybox.pack.js"></script>

<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
